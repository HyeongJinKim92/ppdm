#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <gmp.h>

#include "protocol.h"

#define BOOL int
#define TRUE 1
#define FALSE 0

void	protocol::set_Param(int datanum, int dimension, int bitsize, int requiredK, int tree_level)
{
	NumData = datanum;
	dim = dimension;
	size = bitsize;
	k = requiredK;
	FanOut = datanum / pow(2, tree_level-1);
	printf("tree_level : %d\n", tree_level);
	printf("datanum : %d, dim : %d, bitsize : %d, requiredK : %d, FanOut : %d\n", datanum, dimension, bitsize, requiredK, FanOut);
	totalNumOfRetrievedNodes = 0;

	total_time = 0.0;
	node_SBD_time = 0.0;
	node_SRO_time = 0.0;
	node_expansion_time = 0.0;
	data_extract_first_time = 0.0;
	data_extract_second_time = 0.0;
	data_SSED_SBD_time = 0.0;
	sMINn_first_time = 0.0;
	sMINn_second_time = 0.0;
	data_SBOR_time = 0.0;
}

void protocol::protocol_free(){
	free(pubkey);
	free(prvkey);
	
	paillier_freeplaintext(plain_zero);		paillier_freeplaintext(plain_one);		paillier_freeplaintext(plain_two);		
	paillier_freeplaintext(plain_minus);		paillier_freeplaintext(plain_minus_two);
	paillier_freeplaintext(plain_MAX);		
	
	paillier_freeciphertext(ciper_zero); 	paillier_freeciphertext(ciper_one); paillier_freeciphertext(ciper_minus);	paillier_freeciphertext(l);	// 얘가 뭐하는 애지!!??
	
	free(temp);	// 2차원 포인터 해제로 변경해야 함!!
	paillier_freeciphertext(result);		
	paillier_freeciphertext(ciper_MAX);
}

void	protocol::protocol_setkey(paillier_pubkey_t* pubkey, paillier_prvkey_t* prvkey)
{
	int i;
	this->pubkey = pubkey;
	this->prvkey = prvkey;

	plain_zero = paillier_plaintext_from_ui(0);	// plain_zero를 0으로 셋팅
	plain_one = paillier_plaintext_from_ui(1);		// plain_one을 1로 셋팅
	plain_two = paillier_plaintext_from_ui(2);		// plain_two을 2로 셋팅

	// plain_minus을 -1로 셋팅
	plain_minus = paillier_plaintext_from_ui(0);
	mpz_sub_ui(plain_minus->m, plain_minus->m, 1);

	plain_minus_two = paillier_plaintext_from_ui(2);	
	mpz_powm(plain_minus_two->m, plain_minus_two->m, plain_minus->m, pubkey->n_squared);
	l = paillier_enc(0, pubkey, plain_minus_two, paillier_get_rand_devurandom);

	plain_MAX = paillier_plaintext_from_ui(pow(2, size));


	ciper_zero = paillier_enc(0, pubkey, plain_zero, paillier_get_rand_devurandom);	// ciper_zero를 암호화 0으로 셋팅
	ciper_one = paillier_enc(0, pubkey, plain_one, paillier_get_rand_devurandom);	// ciper_one을 암호화 1로 셋팅
	ciper_minus = paillier_enc(0, pubkey, plain_minus, paillier_get_rand_devurandom);		// ciper_minus를 암호화 -1로 셋팅
	ciper_MAX = paillier_enc(0, pubkey, plain_MAX, paillier_get_rand_devurandom);

	temp  = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*3);
	for( i = 0 ; i < 3 ; i++ ){
		temp[i] = paillier_create_enc_zero();
	}

	result = paillier_create_enc_zero();
}

paillier_ciphertext_t* protocol::SBN(paillier_ciphertext_t* ciper) {
	paillier_ciphertext_t* result = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(result->c);

	paillier_exp(pubkey, result, ciper, plain_minus);	// multiply -1
	paillier_mul(pubkey, result, result, ciper_one);	// plus 1

	return result;
}

// KHJ add
paillier_ciphertext_t** protocol::SBD(paillier_ciphertext_t* ciper1){
	int i = 0;

	paillier_ciphertext_t* t = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(t->c);

	paillier_ciphertext_t** ciper_array = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_array_reverse = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);

	for( i = 0 ; i < size ; i++){
		ciper_array[i] = SBD_underBob(ciper1, i);
		paillier_subtract(pubkey, t, ciper1, ciper_array[i]);
		ciper1 = SM_p1(t, l);
		ciper_array_reverse[size - 1 - i] = ciper_array[i];
	}

	paillier_freeciphertext(t);

	return ciper_array_reverse;
}

// added by KHI. 150712
// int extra : 비트 변환 후 가장 마지막 행에 u=0, v=1인 행을 추가해주기 위한 정보
paillier_ciphertext_t** protocol::SBD_for_SRO(paillier_ciphertext_t* ciper1, int extra){
	int i = 0;

	paillier_ciphertext_t* t = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(t->c);


	paillier_ciphertext_t** ciper_array = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_array_reverse = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));

	for( i = 0 ; i < size ; i++){
		ciper_array[i] = SBD_underBob(ciper1, i);
		paillier_subtract(pubkey, t, ciper1, ciper_array[i]);
		ciper1 = SM_p1(t, l);
		ciper_array_reverse[size - 1 - i] = ciper_array[i];
	}

	if(extra == 1)
		ciper_array_reverse[size] = ciper_one;
	else
		ciper_array_reverse[size] = ciper_zero;

	paillier_freeciphertext(t);

	return ciper_array_reverse;
}

paillier_ciphertext_t*  protocol::SBD_underBob(paillier_ciphertext_t* ciper1, int round){
	int r = rand()%2;

	paillier_plaintext_t* rand = paillier_plaintext_from_ui(r);
	paillier_ciphertext_t* ciper_rand = paillier_enc(0, pubkey, rand , paillier_get_rand_devurandom);	
	paillier_mul(pubkey, ciper_rand, ciper1, ciper_rand);
	paillier_ciphertext_t* sub_result = SBD_underAlice(ciper_rand);

	if( r % 2 == 0 ){
	
	}else{
		paillier_plaintext_t* one = paillier_plaintext_from_ui(1);	
		paillier_ciphertext_t* ciper_one = paillier_enc(0, pubkey, one, paillier_get_rand_devurandom);
		paillier_subtract(pubkey, sub_result, ciper_one, sub_result); 
	}
	paillier_freeciphertext(ciper_rand);
	paillier_freeplaintext(rand);

	return sub_result;
}

paillier_ciphertext_t*  protocol::SBD_underAlice(paillier_ciphertext_t* ciper){
	paillier_plaintext_t* plain = paillier_dec(0, pubkey, prvkey, ciper);

	mpz_mod(plain->m, plain->m, plain_two->m);

	if( mpz_cmp(plain_zero->m, plain->m) == 0){
		paillier_ciphertext_t* ca = paillier_enc(0, pubkey, plain_zero, paillier_get_rand_devurandom);

		return ca;
	}else{
		paillier_ciphertext_t* ca = paillier_enc(0, pubkey, plain_one, paillier_get_rand_devurandom);

		return ca;
	}
}

paillier_ciphertext_t** protocol::Smin_n(paillier_ciphertext_t*** ciper, int number){
	int i, j;
	int iter;
	int num = number;
	int k;
	paillier_ciphertext_t*** copy_ciper = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*num);
	for(i=0; i<num ; i++){
		copy_ciper[i] = ciper[i];
	}
	int e, q;
	
	printf("\n");
/*
	for(j=0;j<10;j++){
		for(i=0; i<10; i++){
				gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, copy_ciper[j][i]));
		}
		printf("\n");
	}
		printf("\n");
*/
	paillier_ciphertext_t** sbd = SBD(paillier_create_enc_zero());
/*
	for(i=0;i<10;i++){
		gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, sbd[i]));
	}
	printf("\n");

	printf("\n");
	printf("\n");
*/
	double n = log10(num)/log10(2) - (int)(log10(num)/log10(2));
	
	
	if(n>0){
		n = (int)(log10(num)/log10(2))+1;
	}else{
		n = (int)(log10(num)/log10(2));
	}
	for (i = 1; i <= n; i++) {
		for (j = 1; j <= num / 2; j++) {
			if (i == 1) {
				e = 2 * j - 2;
				q = 2 * j - 1;
				/*
				for(k=0; k<size; k++){
					gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, copy_ciper[e][k]));
				}
				printf("\n");
				for(k=0; k<size; k++){
					gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, copy_ciper[q][k]));
				}
				printf("\n");
				*/
				copy_ciper[e] = Smin_basic1(copy_ciper[e],copy_ciper[q]);
				copy_ciper[q] = sbd;
				//printf("%d %d\n",e,q);
			} else {
				e = (int)pow(2, i) * (j - 1);
				q = (int)pow(2, i) * j - (int)pow(2, i - 1);
				/*
				for(k=0; k<size; k++){
					gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, copy_ciper[e][k]));
				}
				printf("\n");
				for(k=0; k<size; k++){
					gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, copy_ciper[q][k]));
				}
				printf("\n");
				*/
				copy_ciper[e] = Smin_basic1(copy_ciper[e],copy_ciper[q]);
				copy_ciper[q] = sbd;
				//printf("%d %d\n",e,q);
			}
		}
		if (num % 2 == 0)
			num = num / 2;
		else
			num = num / 2 + 1;

		//printf("%dth iteration finished (out of %d iterations) -> %d %d\n",i, (int)n, e,q);
		printf("%dth round finished (out of %d round)\n",i, (int)n);
	}
	
	free(sbd);
	return copy_ciper[0];
}

paillier_ciphertext_t* protocol::SM_p2(paillier_ciphertext_t* ciper1, paillier_ciphertext_t* ciper2){
	paillier_plaintext_t* plain1 = paillier_dec(0, pubkey, prvkey, ciper1);
	paillier_plaintext_t* plain2 = paillier_dec(0, pubkey, prvkey, ciper2);
	paillier_plaintext_t* result = (paillier_plaintext_t*) malloc(sizeof(paillier_plaintext_t));
	mpz_init(result->m);

	plain_mul(pubkey, result, plain1, plain2);	

	//gmp_printf("The SM_p2 is : %Zd\n",temp);   //test
	paillier_freeplaintext(plain1);
	paillier_freeplaintext(plain2);
	
	return paillier_enc(0, pubkey, result, paillier_get_rand_devurandom);
}

paillier_ciphertext_t* protocol::SM_p1(paillier_ciphertext_t* ciper1, paillier_ciphertext_t* ciper2){
	int i = 0;

	// generate noise (random numbers)
	paillier_plaintext_t* rand1=paillier_plaintext_from_ui(5);
	paillier_plaintext_t* rand2=paillier_plaintext_from_ui(4);

	// encrypt noise 
	paillier_ciphertext_t* ciper_rand1 = paillier_enc(0, pub, rand1, paillier_get_rand_devurandom);
	paillier_ciphertext_t* ciper_rand2 = paillier_enc(0, pub, rand2, paillier_get_rand_devurandom);

	// compute (c1 + rd2) and (c2 + rd1)
	paillier_mul(pub, temp[0], ciper1, ciper_rand1);
	paillier_mul(pub, temp[1], ciper2, ciper_rand2);

	// compute (c1 + rd2) x (c2 + rd1)
	result = SM_p2(temp[0], temp[1]);

	// delete c1 x rnd2 
	paillier_exp(pub, temp[2], ciper1, rand2);
	paillier_subtract(pub, result, result, temp[2]);

	// delete c2 x rnd1
	paillier_exp(pub, temp[2], ciper2, rand1);
	paillier_subtract(pub, result, result, temp[2]);

	// delete rnd1 x rnd2
	paillier_exp(pub, temp[2], ciper_rand1, rand2);
	paillier_subtract(pub, result, result, temp[2]);

	paillier_freeplaintext(rand1);		paillier_freeplaintext(rand2);
	paillier_freeciphertext(ciper_rand1);	paillier_freeciphertext(ciper_rand2);

	return result;
}

paillier_ciphertext_t* protocol::SSED(paillier_ciphertext_t* ciper1, paillier_ciphertext_t* ciper2)
{
	// init variables
	paillier_ciphertext_t* dist = paillier_create_enc_zero();
	paillier_ciphertext_t* tmp_dist = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(tmp_dist->c);
	
	paillier_subtract(pubkey, tmp_dist, ciper1, ciper2);
	dist = SM_p1(tmp_dist, tmp_dist);

	//paillier_print("dist : ", dist);
	paillier_freeciphertext(tmp_dist);
	return dist;
}

paillier_ciphertext_t* protocol::SSEDm(paillier_ciphertext_t** ciper1, paillier_ciphertext_t** ciper2, int col_num)
{
	// init variables
	int i = 0;
	paillier_ciphertext_t* dist = paillier_create_enc_zero();
	paillier_ciphertext_t* tmp_dist = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(tmp_dist->c);

	for( i = 0 ; i < col_num ; i++ )
	{
		paillier_subtract(pubkey, tmp_dist, ciper1[i], ciper2[i]);
		tmp_dist = SM_p1(tmp_dist, tmp_dist);	
		//paillier_print("tmp_dist : ", tmp_dist);
		paillier_mul(pubkey, dist, dist, tmp_dist);
		//paillier_print("dist : ", dist);		
	}

	//printf("SSEDm\n");

	//paillier_print("dist : ", dist);

	paillier_freeciphertext(tmp_dist);

	return dist;
}

paillier_ciphertext_t* protocol::SBOR(paillier_ciphertext_t* ciper1, paillier_ciphertext_t* ciper2)
{
	paillier_ciphertext_t* result = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(result->c);
	paillier_ciphertext_t* temp1 = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(temp1->c);
	paillier_ciphertext_t* temp2 = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(temp2->c);

	// compute (c1 + c2)
	paillier_mul(pubkey, temp1, ciper1, ciper2);

	// compute  (c1*c2)
	temp2 = SM_p1(ciper1, ciper2);

	// compute (c1 + c2 - c1*c2)
	paillier_subtract(pubkey, result, temp1, temp2);

	//paillier_print("result : ", result);

	paillier_freeciphertext(temp1);		paillier_freeciphertext(temp2);

	return result;
}

paillier_ciphertext_t* protocol::SBXOR(paillier_ciphertext_t* ciper1, paillier_ciphertext_t* ciper2)
{
	paillier_ciphertext_t* result = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(result->c);
	paillier_ciphertext_t* temp1 = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(temp1->c);
	paillier_ciphertext_t* temp2 = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(temp2->c);

	// compute (c1 + c2)
	paillier_mul(pubkey, temp1, ciper1, ciper2);

	// compute  (2*c1*c2)
	temp2 = SM_p1(ciper1, ciper2);
	paillier_exp(pubkey, temp2, temp2, plain_two);

	// compute (c1 + c2 -2*c1*c2)
	paillier_subtract(pubkey, result, temp1, temp2);

	//paillier_print("result : ", result);

	paillier_freeciphertext(temp1);		paillier_freeciphertext(temp2);

	return result;
}

paillier_ciphertext_t** protocol::Smin_basic1(paillier_ciphertext_t** ciper1, paillier_ciphertext_t** ciper2)
{
	int i;
	BOOL func = FALSE;
	paillier_plaintext_t* Rand_value = paillier_plaintext_from_ui(5);
	paillier_ciphertext_t* ciper_Rand_value = paillier_enc(0, pubkey, Rand_value, paillier_get_rand_devurandom);

	paillier_ciphertext_t** ciper_W = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_R	 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_H	 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_L	 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_M	 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_lambda = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_min	 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_O = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_G	 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);

	paillier_ciphertext_t* alpha = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(alpha->c);

	paillier_ciphertext_t* tmp		= paillier_create_enc_zero();
	paillier_ciphertext_t** temp	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** temp2	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** temp3	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);

	for(i=0; i<size; i++){
		ciper_W[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_R[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_H[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_L[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_M[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_lambda[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_min[i]	= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_O[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_G[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		temp[i]			= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		temp2[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		temp3[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));

		mpz_init(ciper_W[i]->c);
		mpz_init(ciper_R[i]->c);
		mpz_init(ciper_H[i]->c);
		mpz_init(ciper_L[i]->c);
		mpz_init(ciper_M[i]->c);
		mpz_init(ciper_lambda[i]->c);
		mpz_init(ciper_min[i]->c);
		mpz_init(ciper_O[i]->c);
		mpz_init(ciper_G[i]->c);
		mpz_init(temp[i]->c);
		mpz_init(temp2[i]->c);
		mpz_init(temp3[i]->c);
	}

	for(i=0; i<size; i++){
		if(func){	// true :  F : u>v	
			paillier_subtract(pubkey, ciper_W[i], ciper1[i], SM_p1(ciper1[i], ciper2[i]));	// W
			paillier_subtract(pubkey,temp[i],ciper2[i],ciper1[i]);	
			paillier_mul(pubkey,ciper_R[i],temp[i],ciper_Rand_value);	// Gamma
		}else{
			paillier_subtract(pubkey, ciper_W[i], ciper2[i], SM_p1(ciper1[i], ciper2[i]));
			paillier_subtract(pubkey, temp[i], ciper1[i], ciper2[i]);
			paillier_mul(pubkey, ciper_R[i], temp[i], ciper_Rand_value);
		}
		ciper_G[i]=SBXOR(ciper1[i],ciper2[i]);

		if(i==0){
			paillier_exp(pubkey,ciper_H[i], ciper_zero, Rand_value);
			paillier_mul(pubkey,ciper_H[i], ciper_H[i], ciper_G[i]);		
		}else{
			paillier_exp(pubkey,temp[i],ciper_H[i-1],Rand_value);
			paillier_mul(pubkey,ciper_H[i],temp[i],ciper_G[i]);
		}

		paillier_mul(pubkey,ciper_O[i],ciper_H[i],ciper_minus);	// PI
		paillier_exp(pubkey,ciper_O[i],ciper_O[i],Rand_value);
		// paillier_exp(pubkey,temp3[i],ciper_W[i],Rand_value);   // our IDEA
		// paillier_mul(pubkey,ciper_L[i],temp2[i], temp3[i]);	 // our IDEA
		
		paillier_mul(pubkey, ciper_L[i], ciper_O[i], ciper_W[i]);
	}

	alpha = Smin_basic2(ciper_R, ciper_L, ciper_M, alpha);

	//gmp_printf("alpha %Zd\n", paillier_dec(0, pubkey, prvkey, alpha));
	
	for(i=0;i<size;i++){
		paillier_exp(pubkey,tmp,alpha,Rand_value);
		paillier_subtract(pubkey, ciper_lambda[i], ciper_M[i], tmp);
		if(func){
			paillier_mul(pubkey,ciper_min[i],ciper1[i],ciper_lambda[i]);			
		}else{
			paillier_mul(pubkey,ciper_min[i],ciper2[i],ciper_lambda[i]);			
		}
	}

	paillier_freeplaintext(Rand_value);		 
	paillier_freeciphertext(ciper_Rand_value);	paillier_freeciphertext(tmp);
	
	paillier_freeciphertext(alpha);

	for(i=0; i<size; i++){
		paillier_freeciphertext(ciper_W[i]);	paillier_freeciphertext(ciper_R[i]); paillier_freeciphertext(ciper_H[i]);	paillier_freeciphertext(ciper_L[i]);	paillier_freeciphertext(ciper_M[i]);
		paillier_freeciphertext(temp[i]); paillier_freeciphertext(temp2[i]);	paillier_freeciphertext(temp3[i]);
		paillier_freeciphertext(ciper_lambda[i]);
	}
	
	return ciper_min;
}

paillier_ciphertext_t* protocol::Smin_for_alpha(paillier_ciphertext_t** ciper1, paillier_ciphertext_t** ciper2)
{
	int i;
	BOOL func = FALSE;
	paillier_plaintext_t* Rand_value = paillier_plaintext_from_ui(5);
	paillier_ciphertext_t* ciper_Rand_value = paillier_enc(0, pubkey, Rand_value, paillier_get_rand_devurandom);

	paillier_ciphertext_t** ciper_W = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_G	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_H	 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_L	 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_M	 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_PI = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);

	paillier_ciphertext_t* alpha = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(alpha->c);

	paillier_ciphertext_t* tmp		= paillier_create_enc_zero();
	paillier_ciphertext_t** temp	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** temp2	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);

	for(i=0; i<size; i++){
		ciper_W[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_G[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_H[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_L[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_M[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_PI[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));

		temp[i]			= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		temp2[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));

		mpz_init(ciper_W[i]->c);
		mpz_init(ciper_G[i]->c);
		mpz_init(ciper_H[i]->c);
		mpz_init(ciper_L[i]->c);
		mpz_init(ciper_M[i]->c);
		mpz_init(ciper_PI[i]->c);

		mpz_init(temp[i]->c);
		mpz_init(temp2[i]->c);
	}

	for(i=0; i<size; i++){
		if(func){	// true :  F : u>v	
			paillier_subtract(pubkey, ciper_W[i], ciper1[i], SM_p1(ciper1[i], ciper2[i]));	// W
		}else{
			paillier_subtract(pubkey, ciper_W[i], ciper2[i], SM_p1(ciper1[i], ciper2[i]));
		}

		// compute G
		ciper_G[i]=SBXOR(ciper1[i],ciper2[i]);

		// compute H
		if(i==0){
			paillier_exp(pubkey,ciper_H[i], ciper_zero, Rand_value);
			paillier_mul(pubkey,ciper_H[i], ciper_H[i], ciper_G[i]);		
		}else{
			paillier_exp(pubkey,temp[i],ciper_H[i-1],Rand_value);
			paillier_mul(pubkey,ciper_H[i],temp[i],ciper_G[i]);
		}

		paillier_mul(pubkey,ciper_PI[i],ciper_H[i],ciper_minus);	// PI
		paillier_exp(pubkey,ciper_PI[i],ciper_PI[i],Rand_value);
		// paillier_exp(pubkey,temp3[i],ciper_W[i],Rand_value);   // our IDEA
		// paillier_mul(pubkey,ciper_L[i],temp2[i], temp3[i]);	 // our IDEA
		
		paillier_mul(pubkey, ciper_L[i], ciper_PI[i], ciper_W[i]);
	}

	alpha = SRO2(ciper_L, alpha);

	if(func){
		alpha = SBN(alpha);
	}

	//gmp_printf("alpha : %Zd(%d line)\n", paillier_dec(0, pubkey, prvkey, alpha), __LINE__);
	
	paillier_freeplaintext(Rand_value);		 
	paillier_freeciphertext(ciper_Rand_value);	paillier_freeciphertext(tmp);
	
	for(i=0; i<size; i++){
		paillier_freeciphertext(ciper_W[i]);	paillier_freeciphertext(ciper_H[i]);	paillier_freeciphertext(ciper_L[i]);	paillier_freeciphertext(ciper_M[i]);
		paillier_freeciphertext(temp[i]); paillier_freeciphertext(temp2[i]);	
	}
	
	return alpha;
}

paillier_ciphertext_t* protocol::Smin_basic2(paillier_ciphertext_t** ciper_R, paillier_ciphertext_t** ciper_L, paillier_ciphertext_t** ciper_M, paillier_ciphertext_t* alpha)
{
	int i;
	int flag = 0;

	// compute alpha
	for(i=0; i<size; i++)	{
		if (strcmp( paillier_plaintext_to_str( paillier_dec(0, pubkey, prvkey, ciper_L[i])), paillier_plaintext_to_str(plain_one)) == 0) {
			alpha = paillier_enc(0, pubkey, plain_one, paillier_get_rand_devurandom);
			//paillier_print("alpha : ", alpha);
			
			flag = 1;
			
			break;
		}
		else {
			alpha = paillier_enc(0, pubkey, plain_zero, paillier_get_rand_devurandom);
			//paillier_print("alpha : ", alpha);
		}
	}

	if(flag == 1) {
		for(i=0; i<size; i++){
			paillier_exp(pubkey, ciper_M[i], ciper_R[i], plain_one);
		}
	}
	else {
		for(i=0; i<size; i++){
			paillier_exp(pubkey, ciper_M[i], ciper_R[i], plain_zero);
		}
	}

	//paillier_print("alpha : ", alpha);

	return alpha;
}

int * protocol::SkNNm(paillier_ciphertext_t** ciper, int Q, int k, int row_number){
	int i=0, s=0, n=0, t=0, j=0;
	int rand = 5;
	n = row_number;
	
	paillier_plaintext_t * pt = paillier_plaintext_from_ui(0);

	paillier_ciphertext_t* ciper_binary;
	paillier_ciphertext_t* ciper_min	= paillier_create_enc_zero();
	paillier_ciphertext_t* ciper_dist	= paillier_create_enc_zero();
	
	printf("%d\n", Q);
	printf("%d\n", k);
	printf("%d\n", row_number);
	
	paillier_ciphertext_t* ciper_query = paillier_create_enc(Q);

	paillier_print("query : ",ciper_query);
	for( i = 0 ; i < n ; i++){
		paillier_print("i : ",ciper[i]);
	}

	paillier_ciphertext_t** ciper_distance = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*n);
	paillier_ciphertext_t** ciper_mid = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*n);
	paillier_ciphertext_t** ciper_Smin = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_V;
	paillier_ciphertext_t** ciper_V2 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*n);
	
	paillier_ciphertext_t*  ciper_result = paillier_create_enc_zero();
	paillier_ciphertext_t** ciper_result_array = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*k);
	
	paillier_ciphertext_t*** ciper_SBD_distance = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*n);
	for( i = 0 ; i < n ; i++ ){
		ciper_mid[i] = paillier_create_enc_zero();	// 초기화만 해줘도 될듯!!??
		ciper_SBD_distance[i] = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
		for( j = 0 ; j < size ; j ++ ){
			ciper_SBD_distance[i][j] = paillier_create_enc_zero();	// 초기화만 해줘도 될듯!!??
		}
	}

	for( i = 0 ; i < size; i++ ){
		ciper_Smin[i] = ciper_zero;
	}
	
	paillier_ciphertext_t* ciper_rand = paillier_create_enc(rand);
	
	paillier_print("rand : ",ciper_rand);
	
	for( i = 0 ; i < n ; i++ ){
		ciper_distance[i] = SSED(ciper_query, ciper[i]);
		paillier_print("dist : ", ciper_distance[i]);	
		ciper_SBD_distance[i] = SBD(ciper_distance[i]);
		for( j = 0 ; j < size ; j++ ){
			gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, ciper_SBD_distance[i][j]));
		}
		printf("\n");
	}
	for( s = 0 ; s < k ; s++ ){
		
		ciper_Smin = Smin_n(ciper_SBD_distance, n);

		for( j = 0 ; j < size ; j++ ){
			gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, ciper_Smin[j]));
		}
		printf("\n");	
		
		for( j = size ; j > 0 ; j-- ){
			t = (int)pow(2, j-1);
			ciper_binary = paillier_create_enc(t);
			ciper_binary = SM_p1(ciper_binary, ciper_Smin[size-j]);
			paillier_mul(pubkey, ciper_min, ciper_binary, ciper_min);

			
		}
		paillier_print("min : ",ciper_min);
		
		if( s != 0 ){
			for( i = 0 ; i < n ; i++ ){
				for( j = size ; j > 0 ; j--){
					t = (int)pow(2, j-1);
					ciper_binary = paillier_create_enc(t);
					ciper_binary = SM_p1(ciper_binary, ciper_SBD_distance[i][size-j]);
					paillier_mul(pubkey, ciper_dist, ciper_binary, ciper_dist);
				}
				ciper_distance[i] = ciper_dist;
				ciper_dist = paillier_enc(0, pubkey, pt, paillier_get_rand_devurandom);	 // 전역 ciper_zero 사용해도 되지 않을까!!??
			}
		}

	
		for( i = 0 ; i < n ; i++ ){
			paillier_print("distance : ",ciper_distance[i]);
		}
		
		for( i = 0 ; i < n ; i++ ){
			paillier_ciphertext_t* ciper_temp;
			paillier_subtract(pubkey, ciper_temp, ciper_distance[i], ciper_min);
			ciper_mid[i] = SM_p1(ciper_temp, ciper_rand);
			paillier_print("dist - dist : ",ciper_temp);
		}
		ciper_V = SkNNm_sub(ciper_mid, n);
		for( i = 0 ; i < n ; i++ ){
			paillier_print("ciper_V : ",ciper_V[i]);
		}
		

		for( i = 0 ; i < n ; i++ ){
			ciper_V2[i] = SM_p1(ciper_V[i], ciper[i]);
			paillier_mul(pubkey, ciper_result, ciper_V2[i], ciper_result);
		}
		paillier_print("ciper_result : ",ciper_result);
		
		ciper_result_array[s] = ciper_result;
		for( i = 0 ; i < n ; i++ ){
			for( j = 0; j < size ; j++ ){
				ciper_SBD_distance[i][j] = SBOR(ciper_V[i], ciper_SBD_distance[i][j]);
			}
		}
		ciper_result = paillier_enc(0, pubkey, pt, paillier_get_rand_devurandom);
		ciper_min = paillier_enc(0, pubkey, pt, paillier_get_rand_devurandom);
	}

	for( i = 0 ; i < n ; i++){
		for( j = 0 ; j < size ; j++ ){
				gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, ciper_SBD_distance[i][j]));
			}
		printf("\n");
	}

	for( i = 0 ; i < k ; i++ ){
		paillier_mul(pubkey, ciper_result_array[i],ciper_result_array[i], ciper_rand);
		paillier_print("ciper_result_array : ",ciper_result_array[i]);
	}
	free(ciper_binary);
	free(ciper_min);
	free(pt);
	free(ciper_dist);
	free(ciper_mid);
	free(ciper_Smin);
	free(ciper_V);
	free(ciper_V2);
	free(ciper_result);
	free(ciper_SBD_distance);

	return SkNNm_Bob(ciper_result_array, ciper_rand, k);
}

// SkNN subroutine
paillier_ciphertext_t** protocol::SkNNm_sub(paillier_ciphertext_t** ciper_n, int n){
	int i = 0;
	int cnt = 0;
	paillier_plaintext_t* plain = (paillier_plaintext_t*)malloc(sizeof(paillier_plaintext_t));
	paillier_ciphertext_t** ciper_U = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*n);

	for( i = 0 ; i < n ; i++ ){
		plain = paillier_dec(0, pubkey, prvkey, ciper_n[i]);
		if(  (mpz_cmp(plain_zero->m, plain->m) == 0) && cnt == 0 ){
			ciper_U[i] = paillier_create_enc(1);
			cnt++;
		}
		else{
			ciper_U[i] = paillier_create_enc(0);
		}
	}

	paillier_freeplaintext(plain);

	return ciper_U;
}

// 일차원 SkNN 결과 return 함수
int * protocol::SkNNm_Bob(paillier_ciphertext_t** ciper_result_array, paillier_ciphertext_t* ciper_rand, int k){
	int * kNN = (int *)malloc(sizeof(int)* k);
	int i = 0;
	paillier_plaintext_t* plain;
	for( i = 0 ; i < k ; i++ ){
		paillier_subtract(pubkey, ciper_result_array[i], ciper_result_array[i], ciper_rand);
		plain = paillier_dec(0, pubkey, prvkey, ciper_result_array[i]);
		kNN[i] = mpz_get_ui(plain->m);
	}
	free(plain);
	free(ciper_result_array);
	free(ciper_rand);
	for( i = 0 ; i< k ; i++ ){
		printf("result : %d\n", kNN[i]);
	}
	return kNN;
}

// 다차원 SkNN 결과 return 함수
int ** protocol::SkNNm_Bob2(paillier_ciphertext_t*** ciper_result, paillier_ciphertext_t* ciper_rand, int k, int col_num){
	int i = 0 , j = 0;
	paillier_plaintext_t* plain;

	int ** kNN = (int **)malloc(sizeof(int*)*k);
	for( i = 0 ; i < k ; i++ )
		kNN[i] = (int*)malloc(sizeof(int)*col_num);
	
	for( i = 0 ; i < k ; i++ ){
		for( j = 0 ; j < col_num ; j++ ){
			paillier_subtract(pubkey, ciper_result[i][j], ciper_result[i][j], ciper_rand);
			plain = paillier_dec(0, pubkey, prvkey, ciper_result[i][j]);
			kNN[i][j] = mpz_get_ui(plain->m);
		}
	}

	/*
	for( i = 0 ; i < k ; i++ ){
		printf("%d result : ", (i+1) );
		for ( j = 0 ; j < col_num ; j++ ){
			printf("%d \t", kNN[i][j]);
		}
		printf("\n");
	}
	*/

	paillier_freeplaintext(plain);

	paillier_freeciphertext(ciper_rand);
	for(i=0; i<k; i++) {
		for(j=0; j<dim; j++) {
			paillier_freeciphertext(ciper_result[i][j]);
		}
		free(ciper_result[i]);
	}
	free(ciper_result);

	return kNN;
}

// 다차원 배열 SkNN
int** protocol::SkNNm_2(paillier_ciphertext_t*** data, paillier_ciphertext_t** query, int k, int row_number){
	int i=0, s=0, n=0, t=0, j=0;
	int rand = 5;
	n = row_number;
	
	time_t startTime = 0;
	time_t endTime = 0;
	float gap = 0.0;

	paillier_plaintext_t * pt = paillier_plaintext_from_ui(0);

	paillier_ciphertext_t* ciper_binary;
	paillier_ciphertext_t* ciper_min	= paillier_create_enc_zero();
	paillier_ciphertext_t* ciper_dist	= paillier_create_enc_zero();
	paillier_ciphertext_t* ciper_rand	= paillier_create_enc(rand);
	paillier_ciphertext_t* temp_dist = paillier_create_enc_zero();

	paillier_ciphertext_t** ciper_distance = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*n);
	paillier_ciphertext_t*** ciper_SBD_distance = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*n);
	paillier_ciphertext_t** ciper_mid = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*n);
	paillier_ciphertext_t** ciper_Smin = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*n);
	paillier_ciphertext_t** ciper_V=(paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*n);
	paillier_ciphertext_t*** ciper_V2 = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*n);

	paillier_ciphertext_t*** ciper_result = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*k);

	for( i = 0 ; i < size; i++ ){
		ciper_Smin[i] = ciper_zero;
	}

	for( i = 0 ; i < n ; i++ ){
		ciper_distance[i] 	= ciper_zero;
		ciper_SBD_distance[i] = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
		ciper_V[i]	= ciper_zero;
		ciper_V2[i] = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*dim);
	}

	for( i = 0 ; i < k ; i++ ){
		ciper_result[i] = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*dim);
		for( j = 0 ; j < dim; j ++ ){
			ciper_result[i][j] = paillier_create_enc_zero();
		}
	}


	printf("\n=== Data SSED & SBD start ===\n");
	startTime = clock();
	for( i = 0 ; i < n ; i++ ){
		ciper_distance[i] = SSEDm(query, data[i], dim);
		ciper_SBD_distance[i] = SBD(ciper_distance[i]);
		
		/*
		paillier_print("dist : ", ciper_distance[i]);	
		for( j = 0 ; j < size ; j++ ){
			gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, ciper_SBD_distance[i][j]));
		}
		printf("\n");
		*/		
	}
	endTime = clock();
	data_SSED_SBD_time += (float)(endTime-startTime)/(CLOCKS_PER_SEC);
	printf("data SSED & SBD time : %f\n", (float)(endTime-startTime)/(CLOCKS_PER_SEC));

	for( s = 0 ; s < k ; s++ ){
		printf("\n%dth sMINn start \n", s+1);
		startTime = clock();
		ciper_Smin = Smin_n(ciper_SBD_distance, n);	// bit로 표현된 암호화 min 거리 추출
		endTime = clock();
		gap = (float)(endTime-startTime)/(CLOCKS_PER_SEC);
		sMINn_first_time += gap;
		printf("%dth sMINn time : %f\n", s+1, gap);
	
		/*
		for( j = 0 ; j < size ; j++ ){
			gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, ciper_Smin[j]));
		}
		printf("\n");	
		*/
		
		// bit로 표현된 암호화 min 거리를 암호화 정수로 변환
		for( j = size ; j > 0 ; j-- ){
			t = (int)pow(2, j-1);
			ciper_binary = paillier_create_enc(t);
			ciper_binary = SM_p1(ciper_binary, ciper_Smin[size-j]);
			paillier_mul(pubkey, ciper_min, ciper_binary, ciper_min);
			paillier_freeciphertext(ciper_binary);
			//paillier_print("min : ", ciper_min);
		}
		paillier_print("min dist : ", ciper_min);
		
		printf("\n== recalculate query<->data distances ===\n");
		// 이전 iteration에서 min값으로 선택된 데이터의 거리가 secure하게 MAX로 변환되었기 때문에, 
		// 질의-데이터 간 거리 계산을 모두 다시 수행
		if( s != 0 ){
			for( i = 0 ; i < n ; i++ ){
				for( j = size ; j > 0 ; j--){
					t = (int)pow(2, j-1);
					ciper_binary = paillier_create_enc(t);
					ciper_binary = SM_p1(ciper_binary, ciper_SBD_distance[i][size-j]);
					paillier_mul(pubkey, ciper_dist, ciper_binary, ciper_dist);
				}
				ciper_distance[i] = ciper_dist;
				ciper_dist = paillier_enc(0, pubkey, plain_zero, paillier_get_rand_devurandom);
			}
		}
		
		/*
		for( i = 0 ; i < n ; i++ ){
			paillier_print("distance : ", ciper_distance[i]);
		}
		*/

		// 질의-데이터 거리와 min 거리와의 차를 구함 (min 데이터의 경우에만 0으로 만들기 위함)
		for( i = 0 ; i < n ; i++ ){
			paillier_subtract(pubkey, temp_dist, ciper_distance[i], ciper_min);
			ciper_mid[i] = SM_p1(temp_dist, ciper_rand);
			//paillier_print("dist - dist : ",ciper_mid[i]);
		}

		ciper_V = SkNNm_sub(ciper_mid, n);

		/*
		for( i = 0 ; i < n ; i++ ){
			printf("%d : ", i);
			paillier_print("ciper_V : ", ciper_V[i]);
		}
		*/

		// min 데이터 추출
		for( i = 0 ; i < n ; i++ ){
			for( j = 0 ; j < dim; j++ ){
				ciper_V2[i][j] = SM_p1(ciper_V[i], data[i][j]);
				paillier_mul(pubkey, ciper_result[s][j], ciper_V2[i][j], ciper_result[s][j]);
			}
		}

		printf("ciper_result : ");	
		for( j = 0 ; j < dim; j++ ){
			gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey,ciper_result[s][j]));
		}
		printf("\n");		
		
		// Data SBOR 수행
		startTime = clock();
		for( i = 0 ; i < n ; i++ ){
			for( j = 0; j < size ; j++ ){
				ciper_SBD_distance[i][j] = SBOR(ciper_V[i], ciper_SBD_distance[i][j]);
			}
		}
		endTime = clock();
		data_SBOR_time += (float)(endTime-startTime)/(CLOCKS_PER_SEC);

		ciper_min = paillier_enc(0, pubkey, pt, paillier_get_rand_devurandom);	
	}
	
	// user(Bob)에게 결과 전송을 위해 random 값 삽입
	for(i=0;i<k;i++){
		//printf("%d final result : ", i);
		for(j=0; j<dim; j++){
			paillier_mul(pubkey,ciper_result[i][j],ciper_result[i][j],ciper_rand);
			//gmp_printf("%Zd\t", paillier_dec(0, pubkey, prvkey, ciper_result[i][j]));
		}
		//printf("\n");
	}

	paillier_freeciphertext(temp_dist);	
	
	return SkNNm_Bob2(ciper_result, ciper_rand, k, dim);
}


paillier_ciphertext_t*** protocol::sNodeRetrievalforRange(paillier_ciphertext_t*** data, paillier_ciphertext_t*** ciper_qLL_bit, paillier_ciphertext_t*** ciper_qRR_bit, boundary* node, int NumData, int NumNode, int* cnt, int* NumNodeGroup)
{
	printf("\n===== Now sNodeRetrievalforRange starts =====\n");
	printf("NumNode : %d\n", NumNode);
	int i=0, j=0, m=0;

	time_t startTime = 0;
	time_t endTime = 0;
	float gap = 0.0;

	int** node_group;

	paillier_ciphertext_t*** ciper_nodeLL_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);
	paillier_ciphertext_t*** ciper_nodeRR_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);

	paillier_ciphertext_t** alpha = (paillier_ciphertext_t**) malloc(sizeof(paillier_ciphertext_t*)*NumNode);
	for(i=0; i<NumNode; i++){
		alpha[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		mpz_init(alpha[i]->c);
	}

	// 각 노드 비트 변환 수행 및 SRO 호출
	for(i=0; i<NumNode; i++) {	
		startTime = clock();
		for(j=0; j<dim; j++) {
			ciper_nodeLL_bit[j] = SBD_for_SRO(node[i].LL[j], 0);				// node LL bound 변환
			ciper_nodeRR_bit[j] = SBD_for_SRO(node[i].RR[j], 1);	 			// node RR bound 변환
		}
		endTime = clock();
		gap = (float)(endTime-startTime)/(CLOCKS_PER_SEC);
		printf("%dth node SBD time: %f\n", i, gap);

		
		printf("%dth node LL bound\n", i);
		for(j=0; j<dim; j++) {
			for(m=0; m<size+1; m++) {
				gmp_printf("%Zd", paillier_dec(0, pub, prv, ciper_nodeLL_bit[j][m]));
			}
			printf("\n");
		}
		printf("%dth node RR bound\n", i);
		for(j=0; j<dim; j++) {
			for(m=0; m<size+1; m++) {
				gmp_printf("%Zd", paillier_dec(0, pub, prv, ciper_nodeRR_bit[j][m]));
			}
			printf("\n");
		}
		
		startTime = clock();
		alpha[i] = SRO(ciper_qLL_bit, ciper_qRR_bit, ciper_nodeLL_bit, ciper_nodeRR_bit);		
		endTime = clock();
		gap = (float)(endTime-startTime)/(CLOCKS_PER_SEC);
		printf("SRO time : %f\n", gap);

		if(strcmp( paillier_plaintext_to_str( paillier_dec(0, pub, prv, alpha[i])), paillier_plaintext_to_str(plain_one)) == 0) 
			printf("%dth node overlaps the query region.\n", i);
	}
	
	printf("alpha\n");
	for(i=0; i<NumNode; i++) {
		gmp_printf("%Zd ",paillier_dec(0, pub, prv, alpha[i]));
	}
	printf("\n");
	
	node_group = sRange_sub(alpha, NumNode, NumNodeGroup);
	printf("111set_num : %d\n", *NumNodeGroup);

	for(i=0; i<*NumNodeGroup; i++) {
		printf("%dth Node Group : ", i);
		for(j=1; j<=node_group[i][0]; j++) {	// 0번지에 해당 노드 그룹에 몇개의 노드가 있는지가 저장되어 있음
			printf("%d ", node_group[i][j]);
		}
		printf("\n");
	}

	int nodeId = 0;
	int dataId = 0;
	int z = 0;
	int remained = 0;	  // 노드 그룹 내에서 아직 처리할 데이터가 남아있는 노드가 몇개인지 저장함

	paillier_ciphertext_t** tmp = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*dim);
	for( i = 0 ; i < dim; i++ ){
		tmp[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		mpz_init(tmp[i]->c);
	}

	paillier_ciphertext_t*** cand = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*(*NumNodeGroup)*FanOut);
		
	for( i = 0 ; i < *NumNodeGroup*FanOut ; i++ ){
		cand[i] = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*dim);
		for( j = 0 ; j < dim ; j ++ ){
			cand[i][j] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
			mpz_init(cand[i][j]->c);
		}
	}


	// 노드 그룹 별로 데이터 추출을 통해, 질의 영역을 포함하는 노드 내 데이터 추출
	for(i=0; i<*NumNodeGroup; i++) {
		remained = node_group[i][0];	 // 해당 노드 그룹 내에서 아직 처리할 데이터가 남아있는 노드가 몇개인지 저장함

		for(j=0; j<FanOut; j++) {
			if(remained == 0)	// 해당 노드 그룹 내에서 더 이상 처리할 데이터가 없다면, 다음 노드로 넘어감
				break;

			for(m=1; m<=node_group[i][0]; m++) {	 // 0번지에 해당 노드 그룹에 몇개의 노드가 있는지가 저장되어 있음
				nodeId = node_group[i][m];	 // 노드 그룹에서 노드 ID를 하나씩 꺼냄
				printf("selected node ID : %d\n", nodeId);

				if(node[nodeId].NumData >= j+1) 
				{
					dataId = node[nodeId].indata_id[j];	// 해당 노드에 저장된 데이터 ID를 하나씩 꺼냄
					printf("selected data ID : %d\n", dataId);

					for(z=0; z<dim; z++) {
						if(m == 1) {
							gmp_printf("data : %Zd, alpha : %Zd \n", paillier_dec(0, pub, prv,data[dataId][z]), paillier_dec(0, pub, prv, alpha[nodeId]));
							printf("cnt : %d,  dim : %d\n", *cnt, z);
							cand[*cnt][z] = SM_p1(data[dataId][z], alpha[nodeId]);  // 해당 데이터 ID의 실제 데이터에 접근
							//gmp_printf("%Zd \n", paillier_dec(0, pub, prv, cand[*cnt][z]));
						} else {
							gmp_printf("data : %Zd, alpha : %Zd \n", paillier_dec(0, pub, prv,data[dataId][z]), paillier_dec(0, pub, prv, alpha[nodeId]));
							printf("cnt : %d,  dim : %d\n", *cnt, z);
							tmp[z] = SM_p1(data[dataId][z], alpha[nodeId]);  // 해당 데이터 ID의 실제 데이터에 접근
							//gmp_printf("%Zd \n", paillier_dec(0, pub, prv, cand[*cnt][z]));
							//gmp_printf("%Zd \n", paillier_dec(0, pub, prv, tmp[z]));
							paillier_mul(pub, cand[*cnt][z], cand[*cnt][z], tmp[z]);
							gmp_printf("(%Zd)\n", paillier_dec(0, pub, prv, cand[*cnt][z]));
						}
					}
					printf("\n");

					if(node[nodeId].NumData == j+1)		// 해당 노드가 마지막 데이터를 처리한다면, remained를 1 감소시킴
						remained--;
				}
				else {		// 해당 노드에는 데이터가 없지만, 동일 노드 그룹 내 다른 노드에는 아직 처리할 데이터가 있는 경우를 핸들링
					for(z=0; z<dim; z++) {
						if(m == 1) {
							gmp_printf("data : %Zd, alpha : %Zd \n", paillier_dec(0, pub, prv, ciper_MAX), paillier_dec(0, pub, prv, alpha[nodeId]));
							printf("cnt : %d,  dim : %d\n", *cnt, z);
							cand[*cnt][z] = SM_p1(ciper_MAX, alpha[nodeId]);  // 해당 데이터 ID의 실제 데이터에 접근
							gmp_printf("%Zd \n", paillier_dec(0, pub, prv, cand[*cnt][z]));
						} else {
							gmp_printf("data : %Zd, alpha : %Zd \n", paillier_dec(0, pub, prv, ciper_MAX), paillier_dec(0, pub, prv, alpha[nodeId]));
							printf("cnt : %d,  dim : %d\n", *cnt, z);
							tmp[z] = SM_p1(ciper_MAX, alpha[nodeId]);  // 해당 데이터 ID의 실제 데이터에 접근
							gmp_printf("%Zd \n", paillier_dec(0, pub, prv, cand[*cnt][z]));
							gmp_printf("%Zd \n", paillier_dec(0, pub, prv, tmp[z]));
							paillier_mul(pub, cand[*cnt][z], cand[*cnt][z], tmp[z]);
							gmp_printf("(%Zd)\n", paillier_dec(0, pub, prv, cand[*cnt][z]));
						}
					}
					printf("\n");
				}
			}
			(*cnt)++;	// 노드 그룹의 노드들을 한바퀴 돌고나면, 데이터 하나가 완성됨
		}
	}

	for(i=0; i<*cnt; i++) {
		gmp_printf("%dth data -> coord : ", i);
		for(j=0; j<dim; j++) {
			gmp_printf("%Zd ", paillier_dec(0, pub, prv, cand[i][j]));
		}
		printf("\n");
	}

	return cand;
}

void protocol::sRange(paillier_ciphertext_t*** data, boundary q, boundary* node, int NumData, int NumNode)
{
	printf("\n===== Now sRange starts =====\n");
	printf("NumNode : %d\n", NumNode);
	int i=0, j=0, m=0;

	time_t startTime = 0;
	time_t endTime = 0;
	float gap = 0.0;

	int NumNodeGroup = 0;

	paillier_ciphertext_t*** ciper_qLL_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);
	paillier_ciphertext_t*** ciper_qRR_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);
	paillier_ciphertext_t*** ciper_nodeLL_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);
	paillier_ciphertext_t*** ciper_nodeRR_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);

	
	// query 비트 변환 수행
	for(i=0; i<dim; i++) {
		ciper_qLL_bit[i] = SBD_for_SRO(q.LL[i], 0);			// query LL bound 변환
		ciper_qRR_bit[i] = SBD_for_SRO(q.RR[i], 1);		// query RR bound 변환
	}


	/* 
	printf("Query LL bound\n");
	for(i=0; i<dim; i++) {
		for(j=0; j<size+1; j++) {
			gmp_printf("%Zd", paillier_dec(0, pub, prv, ciper_qLL_bit[i][j]));
		}
		printf("\n");
	}
	printf("Query RR bound\n");
	for(i=0; i<dim; i++) {	
		for(j=0; j<size+1; j++) {
			gmp_printf("%Zd", paillier_dec(0, pub, prv, ciper_qRR_bit[i][j]));
		}
		printf("\n");
	}
	*/


	/*
	paillier_ciphertext_t** alpha = (paillier_ciphertext_t**) malloc(sizeof(paillier_ciphertext_t*)*NumNode);
	for(i=0; i<NumNode; i++){
		alpha[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		mpz_init(alpha[i]->c);
	}
	*/
	/*		
	paillier_ciphertext_t*** cand = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*(*NumNodeGroup)*FanOut);
	for( i = 0 ; i < *NumNodeGroup*FanOut ; i++ ){
		cand[i] = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*dim);
		for( j = 0 ; j < dim ; j ++ ){
			cand[i][j] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
			mpz_init(cand[i][j]->c);
		}
	}
	*/

	int cnt = 0;	 // 질의 영역과 겹치는 노드 내에 존재하는 총 데이터의 수

	paillier_ciphertext_t*** cand ;

	cand = sNodeRetrievalforRange(data, ciper_qLL_bit, ciper_qRR_bit, node, NumData, NumNode, &cnt, &NumNodeGroup);

	paillier_ciphertext_t*** candLL_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);
	paillier_ciphertext_t*** candRR_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);

	paillier_ciphertext_t** alpha = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*cnt);

	// cand 비트 변환 수행 및 SPE호출
	for(i=0; i<cnt; i++) {
		for(j=0; j<dim; j++) {
			candLL_bit[j] = SBD_for_SRO(cand[i][j], 0);			// query cand 변환
			candRR_bit[j] = SBD_for_SRO(cand[i][j], 1);		
		}		
		alpha[i]=SRO(candLL_bit,candRR_bit,ciper_qLL_bit, ciper_qRR_bit);
		//alpha[i]=SPE(cand_bit,ciper_nodeLL_bit, ciper_nodeRR_bit);		
	}

	//알파값 확인
	printf("SPE alpha\n");
	for(i=0; i<cnt; i++) {
		gmp_printf("%Zd ",paillier_dec(0, pub, prv, alpha[i]));
	}
	printf("\n");	

	paillier_ciphertext_t*** result = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*NumNodeGroup*FanOut); //할당방법 변경해야하고
	int result_num=0;

	//값 확인 && If αi = 1, E(t’i)를 result에 삽입
	for(i=0; i<cnt; i++){
		if(strcmp( paillier_plaintext_to_str( paillier_dec(0, pub, prv, alpha[i])), paillier_plaintext_to_str(plain_one)) == 0) 
		{
			printf("%dth point overlaps the query region.\n", i);	//값 확인 		
			gmp_printf("%dth data -> coord : ", i);
			for(j=0; j<dim; j++) {
				gmp_printf("%Zd ", paillier_dec(0, pub, prv, cand[i][j]));				
			}

			result[result_num]=cand[i]; //result에 삽입
			result_num++;
			printf("\n");
		}	
	}
	
	//result 확인
	for(i=0;i<result_num;i++){
		printf("%dth result.\n", i);
		for(j=0; j<dim; j++) {				
				gmp_printf("%Zd ", paillier_dec(0, pub, prv, result[i][j]));				
			}
		printf("\n");
	}
}

// added by KHI. 150808
paillier_ciphertext_t* protocol::SCMP(paillier_ciphertext_t** u, paillier_ciphertext_t** v)
{
	//printf("\n===== Now SRO starts ===== \n");
	
	int i, j = 0;
	
	BOOL func = false;
	paillier_plaintext_t* Rand_value=paillier_plaintext_from_ui(5);
	paillier_ciphertext_t* ciper_Rand_value = paillier_enc(0, pubkey, Rand_value, paillier_get_rand_devurandom);	

	paillier_ciphertext_t** ciper_W		 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_G	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_H		 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_L		 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_M		 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_PI	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));

	paillier_ciphertext_t* alpha = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(alpha->c);

	paillier_ciphertext_t* tmp		= paillier_create_enc_zero();
	paillier_ciphertext_t** temp	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** temp2	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));

	for(i=0; i<size+1; i++){
		ciper_W[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_G[i]	 = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_H[i]	 = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_L[i]	= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_M[i]	 = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_PI[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		temp[i]	= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		temp2[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));

		mpz_init(ciper_W[i]->c);
		mpz_init(ciper_G[i]->c);
		mpz_init(ciper_H[i]->c);
		mpz_init(ciper_L[i]->c);
		mpz_init(ciper_M[i]->c);
		mpz_init(ciper_PI[i]->c);
		mpz_init(temp[i]->c);
		mpz_init(temp2[i]->c);
	}
		
	for(i=0; i<size+1; i++) {
		// compute W
		if(func){	// true :  F : u>v	
			paillier_subtract(pubkey, ciper_W[i], u[i], SM_p1(u[i], v[i]));	
		}else{
			paillier_subtract(pubkey, ciper_W[i], v[i], SM_p1(u[i], v[i]));
		}

		// compute G
		ciper_G[i]=SBXOR(u[i], v[i]);

		// compute H
		if(i==0){
			paillier_exp(pubkey,ciper_H[i], ciper_zero, Rand_value);
			paillier_mul(pubkey,ciper_H[i], ciper_H[i], ciper_G[i]);
		}else{
			paillier_exp(pubkey,temp[i],ciper_H[i-1],Rand_value);
			paillier_mul(pubkey,ciper_H[i],temp[i],ciper_G[i]);
		}
	}

	// debugging
	/*
	printf("\nW : ");
	for(i=0; i<size+1; i++) {
		gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, ciper_W[i]));
	}
	printf("\nG : ");
	for(i=0; i<size+1; i++) {
		gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, ciper_G[i]));
	}

	printf("\nH : ");
	for(i=0; i<size+1; i++) {
		gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, ciper_H[i]));
	}
	*/

	for(i=0; i<size+1; i++){
		// compute PI
		paillier_mul(pubkey, ciper_PI[i], ciper_H[i], ciper_minus);	// PI

		// compute L with enhanced privacy (new IDEA)
		mpz_init(temp[i]->c);
		paillier_exp(pubkey,temp[i],ciper_PI[i],Rand_value);	// randomize PI
		paillier_exp(pubkey,temp2[i],ciper_W[i],Rand_value); // randomize W
		paillier_mul(pubkey,ciper_L[i],temp[i], temp2[i]);
	}
	
	// debugging
	/* 
	printf("\nPI : ");
	for(i=0; i<size+1; i++) {
		gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, ciper_PI[i]));
	}

	printf("\nL : ");
	for(i=0; i<size+1; i++) {
		gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, ciper_L[i]));
	}
	printf("\n");
	*/

	alpha = SRO2(ciper_L, alpha);

	if(func){
		alpha = SBN(alpha);
	}
	//gmp_printf("alpha %Zd\n", paillier_dec(0, pubkey, prvkey, alpha));

	// free memory
	paillier_freeplaintext(Rand_value);	 
	paillier_freeciphertext(ciper_Rand_value);		paillier_freeciphertext(tmp);

	for(i=0; i<size+1; i++){
		paillier_freeciphertext(ciper_W[i]);	paillier_freeciphertext(ciper_H[i]);	paillier_freeciphertext(ciper_L[i]);	paillier_freeciphertext(ciper_M[i]);
		paillier_freeciphertext(temp[i]); paillier_freeciphertext(temp2[i]);	
	}

	return alpha;
		
}

// added by KHI. 150711
paillier_ciphertext_t* protocol::SRO(paillier_ciphertext_t*** qLL, paillier_ciphertext_t*** qRR, paillier_ciphertext_t*** nodeLL, paillier_ciphertext_t*** nodeRR)
{
	//printf("\n===== Now SRO starts ===== \n");
	
	int i, j = 0;
	
	BOOL func = false;
	paillier_plaintext_t* Rand_value=paillier_plaintext_from_ui(5);
	paillier_ciphertext_t* ciper_Rand_value = paillier_enc(0, pubkey, Rand_value, paillier_get_rand_devurandom);	

	paillier_ciphertext_t** ciper_W		 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_G	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_H		 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_L		 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_M		 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_PI	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));

	paillier_ciphertext_t* alpha = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(alpha->c);
	paillier_ciphertext_t* final_alpha = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(final_alpha->c);

	paillier_ciphertext_t* tmp		= paillier_create_enc_zero();
	paillier_ciphertext_t** temp	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** temp2	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));

	for(i=0; i<size+1; i++){
		ciper_W[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_G[i]	 = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_H[i]	 = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_L[i]	= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_M[i]	 = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_PI[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		temp[i]	= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		temp2[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));

		mpz_init(ciper_W[i]->c);
		mpz_init(ciper_G[i]->c);
		mpz_init(ciper_H[i]->c);
		mpz_init(ciper_L[i]->c);
		mpz_init(ciper_M[i]->c);
		mpz_init(ciper_PI[i]->c);
		mpz_init(temp[i]->c);
		mpz_init(temp2[i]->c);
	}

	// q.LL 및 node.RR에 대해서 수행
	for(i=0; i<dim; i++) {
		//printf("\n%dth dimension\n", i);
		
		for(j=0; j<size+1; j++) {
			// compute W
			if(func){	// true :  F : u>v	
				paillier_subtract(pubkey, ciper_W[j], qLL[i][j], SM_p1(qLL[i][j], nodeRR[i][j]));	
			}else{
				paillier_subtract(pubkey, ciper_W[j], nodeRR[i][j], SM_p1(qLL[i][j], nodeRR[i][j]));
			}

			// compute G
			ciper_G[j]=SBXOR(qLL[i][j],nodeRR[i][j]);

			// compute H
			if(j==0){
				paillier_exp(pubkey,ciper_H[j], ciper_zero, Rand_value);
				paillier_mul(pubkey,ciper_H[j], ciper_H[j], ciper_G[j]);
			}else{
				paillier_exp(pubkey,temp[j],ciper_H[j-1],Rand_value);
				paillier_mul(pubkey,ciper_H[j],temp[j],ciper_G[j]);
			}
		}
	/*	
		printf("\nW : ");
		for(j=0; j<size+1; j++) {
			gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, ciper_W[j]));
		}
		printf("\nG : ");
		for(j=0; j<size+1; j++) {
			gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, ciper_G[j]));
		}

		printf("\nH : ");
		for(j=0; j<size+1; j++) {
			gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, ciper_H[j]));
		}
	*/	

		for(j=0; j<size+1; j++){
			// compute PI
			paillier_mul(pubkey, ciper_PI[j], ciper_H[j], ciper_minus);	// PI

			// compute L with enhanced privacy (new IDEA)
			mpz_init(temp[i]->c);
			paillier_exp(pubkey,temp[j],ciper_PI[j],Rand_value);	// randomize PI
			paillier_exp(pubkey,temp2[j],ciper_W[j],Rand_value); // randomize W
			paillier_mul(pubkey,ciper_L[j],temp[j], temp2[j]);
		}
	/*	
		printf("\nPI : ");
		for(j=0; j<size+1; j++) {
			gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, ciper_PI[j]));
		}

		printf("\nL : ");
		for(j=0; j<size+1; j++) {
			gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, ciper_L[j]));
		}
		printf("\n");
	*/	
		alpha = SRO2(ciper_L, alpha);

		if(func){
			alpha = SBN(alpha);
		}
		//gmp_printf("alpha %Zd\n", paillier_dec(0, pubkey, prvkey, alpha));
	
		// AND operation (using SM Protocol) 
		if(i == 0)
			final_alpha = SM_p1(ciper_one, alpha);	// 최초에는 1과 AND 연산을 해야함. 한번이라도 0이 나오면 0으로 바뀌는 논리
		else
			final_alpha = SM_p1(final_alpha, alpha);

		//gmp_printf("final alpha (after) %Zd\n", paillier_dec(0, pubkey, prvkey, alpha));
	}


	// q.RR 및 node.LL에 대해서 수행
	for(i=0; i<dim; i++) {
		//printf("\n%dth dimension\n", i);
		
		for(j=0; j<size+1; j++) {
			// compute W
			if(func){	// true :  F : u>v	
				paillier_subtract(pubkey, ciper_W[j], nodeLL[i][j], SM_p1(nodeLL[i][j], qRR[i][j]));	
			}else{
				paillier_subtract(pubkey, ciper_W[j], qRR[i][j], SM_p1(nodeLL[i][j], qRR[i][j]));
			}

			// compute G
			ciper_G[j]=SBXOR(nodeLL[i][j], qRR[i][j]);

			// compute H
			if(j==0){
				paillier_exp(pubkey,ciper_H[j], ciper_zero, Rand_value);
				paillier_mul(pubkey,ciper_H[j], ciper_H[j], ciper_G[j]);
			}else{
				paillier_exp(pubkey,temp[j],ciper_H[j-1],Rand_value);
				paillier_mul(pubkey,ciper_H[j],temp[j],ciper_G[j]);
			}
		}
		/*
		printf("\nW : ");
		for(j=0; j<size+1; j++) {
			gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, ciper_W[j]));
		}
		printf("\nG : ");
		for(j=0; j<size+1; j++) {
			gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, ciper_G[j]));
		}

		printf("\nH : ");
		for(j=0; j<size+1; j++) {
			gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, ciper_H[j]));
		}
		*/
		for(j=0; j<size+1; j++){
			// compute PI
			paillier_mul(pubkey, ciper_PI[j], ciper_H[j], ciper_minus);	// PI

			// compute L with enhanced privacy (new IDEA)
			mpz_init(temp[i]->c);
			paillier_exp(pubkey,temp[j],ciper_PI[j],Rand_value);	// randomize PI
			paillier_exp(pubkey,temp2[j],ciper_W[j],Rand_value); // randomize W
			paillier_mul(pubkey,ciper_L[j],temp[j], temp2[j]);
		}
		/*
		printf("\nPI : ");
		for(j=0; j<size+1; j++) {
			gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, ciper_PI[j]));
		}

		printf("\nL : ");
		for(j=0; j<size+1; j++) {
			gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, ciper_L[j]));
		}
		printf("\n");
		*/
		alpha = SRO2(ciper_L, alpha);

		if(func){
			alpha = SBN(alpha);
		}
		//gmp_printf("alpha %Zd\n", paillier_dec(0, pubkey, prvkey, alpha));
	
		// AND operation (using SM Protocol) 
		final_alpha = SM_p1(final_alpha, alpha);

		//gmp_printf("final alpha (after) %Zd\n", paillier_dec(0, pubkey, prvkey, alpha));
	}

	// free memory
	paillier_freeplaintext(Rand_value);	 
	paillier_freeciphertext(ciper_Rand_value);		paillier_freeciphertext(tmp);

	paillier_freeciphertext(alpha);	
	
	for(i=0; i<size+1; i++){
		paillier_freeciphertext(ciper_W[i]);	paillier_freeciphertext(ciper_H[i]);	paillier_freeciphertext(ciper_L[i]);	paillier_freeciphertext(ciper_M[i]);
		paillier_freeciphertext(temp[i]); paillier_freeciphertext(temp2[i]);	
	}

	return final_alpha;
		
}

// added by KHI. 150711
paillier_ciphertext_t*  protocol::SRO2(paillier_ciphertext_t** ciper_L, paillier_ciphertext_t* alpha)
{
	int i;

	// compute alpha
	for(i=0; i<size; i++)	{
		if (strcmp( paillier_plaintext_to_str( paillier_dec(0, pubkey, prvkey, ciper_L[i])), paillier_plaintext_to_str(plain_zero)) == 0) {
			alpha = paillier_enc(0, pubkey, plain_zero, paillier_get_rand_devurandom);
			//paillier_print("alpha 0 : ", alpha);
			break;
		}
		else {
			alpha = paillier_enc(0, pubkey, plain_one, paillier_get_rand_devurandom);
			//paillier_print("alpha 1 : ", alpha);
		}
	}

	//paillier_print("alpha : ", alpha);
	
	return alpha;
}

paillier_ciphertext_t* protocol::SPE(paillier_ciphertext_t*** qBound, paillier_ciphertext_t*** nodeLL, paillier_ciphertext_t*** nodeRR)
{
	printf("\n===== Now SPE starts ===== \n");
	
	int i, j = 0;
	
	BOOL func = false;
	paillier_plaintext_t* Rand_value=paillier_plaintext_from_ui(5);
	paillier_ciphertext_t* ciper_Rand_value = paillier_enc(0, pubkey, Rand_value, paillier_get_rand_devurandom);	

	paillier_ciphertext_t** ciper_W		 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_G	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_H		 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_L		 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_M		 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_PI	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));

	paillier_ciphertext_t* alpha = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(alpha->c);
	paillier_ciphertext_t* final_alpha = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(final_alpha->c);

	paillier_ciphertext_t* tmp		= paillier_create_enc_zero();
	paillier_ciphertext_t** temp	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** temp2	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));

	for(i=0; i<size+1; i++){
		ciper_W[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_G[i]	 = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_H[i]	 = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_L[i]	= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_M[i]	 = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_PI[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		temp[i]	= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		temp2[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));

		mpz_init(ciper_W[i]->c);
		mpz_init(ciper_G[i]->c);
		mpz_init(ciper_H[i]->c);
		mpz_init(ciper_L[i]->c);
		mpz_init(ciper_M[i]->c);
		mpz_init(ciper_PI[i]->c);
		mpz_init(temp[i]->c);
		mpz_init(temp2[i]->c);
	}

	

	// q.LL 및 node.RR에 대해서 수행
	for(i=0; i<dim; i++) {
		printf("\n%dth dimension\n", i);
		
		for(j=0; j<size+1; j++) {
			// compute W
			if(func){	// true :  F : u>v	
				paillier_subtract(pubkey, ciper_W[j], qBound[i][j], SM_p1(qBound[i][j], nodeRR[i][j]));					
			}else{
				paillier_subtract(pubkey, ciper_W[j], nodeRR[i][j], SM_p1(qBound[i][j], nodeRR[i][j]));				
			}

			// compute G
			ciper_G[j]=SBXOR(qBound[i][j],nodeRR[i][j]);

			// compute H
			if(j==0){
				paillier_exp(pubkey,ciper_H[j], ciper_zero, Rand_value);
				paillier_mul(pubkey,ciper_H[j], ciper_H[j], ciper_G[j]);
			}else{
				paillier_exp(pubkey,temp[j],ciper_H[j-1],Rand_value);
				paillier_mul(pubkey,ciper_H[j],temp[j],ciper_G[j]);
			}

		}

		for(j=0; j<size+1; j++){
			// compute PI
			paillier_mul(pubkey, ciper_PI[j], ciper_H[j], ciper_minus);	// PI

			// compute L with enhanced privacy (new IDEA)
			mpz_init(temp[i]->c);
			paillier_exp(pubkey,temp[j],ciper_PI[j],Rand_value);	// randomize PI
			paillier_exp(pubkey,temp2[j],ciper_W[j],Rand_value); // randomize W
			paillier_mul(pubkey,ciper_L[j],temp[j], temp2[j]);
		}

		alpha = SRO2(ciper_L, alpha);

		if(func){
			alpha = SBN(alpha);
		}
		//gmp_printf("alpha %Zd\n", paillier_dec(0, pubkey, prvkey, alpha));
	
		// AND operation (using SM Protocol) 
		if(i == 0)
			final_alpha = SM_p1(ciper_one, alpha);	// 최초에는 1과 AND 연산을 해야함. 한번이라도 0이 나오면 0으로 바뀌는 논리
		else
			final_alpha = SM_p1(final_alpha, alpha);

		//gmp_printf("final alpha (after) %Zd\n", paillier_dec(0, pubkey, prvkey, alpha));
	}


	// q.RR 및 node.LL에 대해서 수행
	for(i=0; i<dim; i++) {
		//printf("\n%dth dimension\n", i);
		
		for(j=0; j<size+1; j++) {
			// compute W
			if(func){	// true :  F : u>v	
				paillier_subtract(pubkey, ciper_W[j], nodeLL[i][j], SM_p1(nodeLL[i][j], qBound[i][j]));	
			}else{
				paillier_subtract(pubkey, ciper_W[j], qBound[i][j], SM_p1(nodeLL[i][j], qBound[i][j]));
			}

			// compute G
			ciper_G[j]=SBXOR(nodeLL[i][j], qBound[i][j]);

			// compute H
			if(j==0){
				paillier_exp(pubkey,ciper_H[j], ciper_zero, Rand_value);
				paillier_mul(pubkey,ciper_H[j], ciper_H[j], ciper_G[j]);
			}else{
				paillier_exp(pubkey,temp[j],ciper_H[j-1],Rand_value);
				paillier_mul(pubkey,ciper_H[j],temp[j],ciper_G[j]);
			}
		}

		for(j=0; j<size+1; j++){
			// compute PI
			paillier_mul(pubkey, ciper_PI[j], ciper_H[j], ciper_minus);	// PI

			// compute L with enhanced privacy (new IDEA)
			mpz_init(temp[i]->c);
			paillier_exp(pubkey,temp[j],ciper_PI[j],Rand_value);	// randomize PI
			paillier_exp(pubkey,temp2[j],ciper_W[j],Rand_value); // randomize W
			paillier_mul(pubkey,ciper_L[j],temp[j], temp2[j]);
		}

		alpha = SRO2(ciper_L, alpha);

		if(func){
			alpha = SBN(alpha);
		}
		//gmp_printf("alpha %Zd\n", paillier_dec(0, pubkey, prvkey, alpha));
	
		// AND operation (using SM Protocol) 
		final_alpha = SM_p1(final_alpha, alpha);

		//gmp_printf("final alpha (after) %Zd\n", paillier_dec(0, pubkey, prvkey, alpha));
	}

	// free memory
	paillier_freeplaintext(Rand_value);	 
	paillier_freeciphertext(ciper_Rand_value);		paillier_freeciphertext(tmp);

	paillier_freeciphertext(alpha);
	
	for(i=0; i<size+1; i++){
		paillier_freeciphertext(ciper_W[i]);	paillier_freeciphertext(ciper_H[i]);	paillier_freeciphertext(ciper_L[i]);	paillier_freeciphertext(ciper_M[i]);
		paillier_freeciphertext(temp[i]); paillier_freeciphertext(temp2[i]);	
	}

	return final_alpha;
		
}


//KHJ 
int ** protocol::sRange_sub(paillier_ciphertext_t** alpha, int node_num, int * set_num){
	int i = 0, j = 0, k = 0;
	int cnt = 0;
	int node_set_size = 0;
	int ** sRange_sub_result;
	paillier_plaintext_t** plain_alpha = (paillier_plaintext_t**)malloc(sizeof(paillier_plaintext_t*)*node_num);
	for( i = 0 ; i < node_num ; i++ )
	{
		plain_alpha[i] = paillier_dec(0, pub, prv, alpha[i]);
		if (strcmp( paillier_plaintext_to_str( plain_alpha[i] ), paillier_plaintext_to_str(plain_one)) == 0) {
			cnt++;
		}
	}
	//printf("cnt : %d\n", cnt);
	*set_num = cnt;
	//printf("set_num : %d\n", *set_num);
	
	if(cnt == 0)
		return 0;

	// cnt 은  dec(alpha) == 1 인 개수
	// node_num %cnt >0 이면 하나의 배열을 추가해서 생성해야함
	if( (node_num % cnt) > 0 ){
		node_set_size = node_num/cnt + 1;
	}else{
		node_set_size = node_num/cnt;
	}
	//초기 배열 -1 로 세팅
	sRange_sub_result = (int **)malloc(sizeof(int *)*cnt);
	for( i = 0 ; i < cnt ; i++ )
	{
		sRange_sub_result[i] = (int *)malloc(sizeof(int)*(node_set_size+1));
		for( j = 0 ; j < node_set_size+1 ; j++)
		{
			sRange_sub_result[i][j] = -1;
		}
		printf("\n");
	}
	j = 0;
	for( i = 0 ; i < node_num ; i++ )
	{
		if (strcmp( paillier_plaintext_to_str( plain_alpha[i] ), paillier_plaintext_to_str(plain_one)) == 0) {
			//printf("equal  :  %d \t input : %d\n", i, j);
			sRange_sub_result[j][1] = i;
			sRange_sub_result[j][0] = 1;
			j++;
		}
	}
	j = 0;
	k = 2;
	for( i = 0 ; i < node_num ; i++ )
	{
		if (strcmp( paillier_plaintext_to_str( plain_alpha[i] ), paillier_plaintext_to_str(plain_one)) != 0) {
			sRange_sub_result[j][k] = i;
			sRange_sub_result[j][0] = k;
			k++;
			if( k == (node_set_size+1) )
			{
				k = 2;
				j++;
				j = j % cnt;
			}
		}
	}
	/*
	printf("result\n");	
	for( i = 0 ; i < cnt ; i++ ){
		for( j = 0 ; j < node_set_size+1 ; j++){
			printf("%d  ", sRange_sub_result[i][j]);
		}
		printf("\n");
	}*/
	return sRange_sub_result;
}

// 150809. added by KHI.
paillier_ciphertext_t* protocol::computeScore(paillier_ciphertext_t** ciper1, paillier_ciphertext_t** ciper2)
{
	// init variables
	int i = 0;
	paillier_ciphertext_t* score = paillier_create_enc_zero();
	paillier_ciphertext_t* tmp_score = 0; 

	for( i = 0 ; i < dim; i++ )
	{
		tmp_score = SM_p1(ciper1[i], ciper2[i]);	
		gmp_printf("tmp_score : %Zd\n", paillier_dec(0, pubkey, prvkey, tmp_score));
		paillier_mul(pubkey, score, score, tmp_score);
		gmp_printf("score : %Zd\n", paillier_dec(0, pubkey, prvkey, score));		
	}

	paillier_freeciphertext(tmp_score);

	return score;
}

// 150809. added by KHI.
paillier_ciphertext_t* protocol::computeScore2(paillier_ciphertext_t** ciper1, paillier_ciphertext_t** ciper2, paillier_ciphertext_t** coeff, paillier_ciphertext_t* hint)
{
	// init variables
	int i = 0;
	paillier_ciphertext_t* score = paillier_create_enc_zero();
	paillier_ciphertext_t* tmp_score = 0; 

	for( i = 0 ; i < dim; i++ )
	{
		tmp_score = SM_p1(coeff[i], ciper2[i]);	
		gmp_printf("tmp_score : %Zd\n", paillier_dec(0, pubkey, prvkey, tmp_score));
		paillier_subtract(pubkey, tmp_score, tmp_score, SM_p1(hint, ciper2[i]));
		gmp_printf("tmp_score : %Zd\n", paillier_dec(0, pubkey, prvkey, tmp_score));
		paillier_mul(pubkey, score, score, tmp_score);
		gmp_printf("score : %Zd\n", paillier_dec(0, pubkey, prvkey, score));		
	}

	paillier_freeciphertext(tmp_score);

	return score;
}


// 150809. added by KHI.
paillier_ciphertext_t** protocol::Smax_n(paillier_ciphertext_t*** ciper, int number){
	int i, j;
	int iter;
	int num = number;
	int k;
	paillier_ciphertext_t*** copy_ciper = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*num);
	for(i=0; i<num ; i++){
		copy_ciper[i] = ciper[i];
	}
	int e, q;
	
	for(i=0;i<num;i++){
		for(j=0; j<size; j++){
				gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, copy_ciper[i][j]));
		}
		printf("\n");
	}
	printf("\n");

	paillier_ciphertext_t** sbd = SBD(paillier_create_enc_zero());

	double n = log10(num)/log10(2) - (int)(log10(num)/log10(2));
	
	
	if(n>0){
		n = (int)(log10(num)/log10(2))+1;
	}else{
		n = (int)(log10(num)/log10(2));
	}
	for (i = 1; i <= n; i++) {
		for (j = 1; j <= num / 2; j++) {
			if (i == 1) {
				e = 2 * j - 2;
				q = 2 * j - 1;
				/*
				for(k=0; k<size; k++){
					gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, copy_ciper[e][k]));
				}
				printf("\n");
				for(k=0; k<size; k++){
					gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, copy_ciper[q][k]));
				}
				printf("\n");
				*/
				copy_ciper[e] = Smax_basic1(copy_ciper[e],copy_ciper[q]);
				copy_ciper[q] = sbd;
				//printf("%d %d\n",e,q);
			} else {
				e = (int)pow(2, i) * (j - 1);
				q = (int)pow(2, i) * j - (int)pow(2, i - 1);
				/*
				for(k=0; k<size; k++){
					gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, copy_ciper[e][k]));
				}
				printf("\n");
				for(k=0; k<size; k++){
					gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, copy_ciper[q][k]));
				}
				printf("\n");
				*/
				copy_ciper[e] = Smax_basic1(copy_ciper[e],copy_ciper[q]);
				copy_ciper[q] = sbd;
				//printf("%d %d\n",e,q);
			}
		}
		if (num % 2 == 0)
			num = num / 2;
		else
			num = num / 2 + 1;

		//printf("%dth iteration finished (out of %d iterations) -> %d %d\n",i, (int)n, e,q);
		printf("%dth round finished (out of %d round)\n",i, (int)n);
	}
	
	free(sbd);
	return copy_ciper[0];
}

// 150809. added by KHI.
paillier_ciphertext_t** protocol::Smax_basic1(paillier_ciphertext_t** ciper1, paillier_ciphertext_t** ciper2)
{
	int i;
	BOOL func = FALSE;
	paillier_plaintext_t* Rand_value = paillier_plaintext_from_ui(5);
	paillier_ciphertext_t* ciper_Rand_value = paillier_enc(0, pubkey, Rand_value, paillier_get_rand_devurandom);

	paillier_ciphertext_t** ciper_W = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_R	 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_H	 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_L	 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_M	 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_lambda = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_min	 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_O = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** ciper_G	 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);

	paillier_ciphertext_t* alpha = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	mpz_init(alpha->c);

	paillier_ciphertext_t* tmp		= paillier_create_enc_zero();
	paillier_ciphertext_t** temp	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** temp2	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);
	paillier_ciphertext_t** temp3	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size);

	for(i=0; i<size; i++){
		ciper_W[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_R[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_H[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_L[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_M[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_lambda[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_min[i]	= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_O[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_G[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		temp[i]			= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		temp2[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		temp3[i]		= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));

		mpz_init(ciper_W[i]->c);
		mpz_init(ciper_R[i]->c);
		mpz_init(ciper_H[i]->c);
		mpz_init(ciper_L[i]->c);
		mpz_init(ciper_M[i]->c);
		mpz_init(ciper_lambda[i]->c);
		mpz_init(ciper_min[i]->c);
		mpz_init(ciper_O[i]->c);
		mpz_init(ciper_G[i]->c);
		mpz_init(temp[i]->c);
		mpz_init(temp2[i]->c);
		mpz_init(temp3[i]->c);
	}

	for(i=0; i<size; i++){
		if(func){	// true :  F : u>v	
			paillier_subtract(pubkey, ciper_W[i], ciper1[i], SM_p1(ciper1[i], ciper2[i]));	// W
			paillier_subtract(pubkey,temp[i],ciper2[i],ciper1[i]);	
			paillier_mul(pubkey,ciper_R[i],temp[i],ciper_Rand_value);	// Gamma
		}else{
			paillier_subtract(pubkey, ciper_W[i], ciper2[i], SM_p1(ciper1[i], ciper2[i]));
			paillier_subtract(pubkey, temp[i], ciper1[i], ciper2[i]);
			paillier_mul(pubkey, ciper_R[i], temp[i], ciper_Rand_value);
		}
		ciper_G[i]=SBXOR(ciper1[i],ciper2[i]);

		if(i==0){
			paillier_exp(pubkey,ciper_H[i], ciper_zero, Rand_value);
			paillier_mul(pubkey,ciper_H[i], ciper_H[i], ciper_G[i]);		
		}else{
			paillier_exp(pubkey,temp[i],ciper_H[i-1],Rand_value);
			paillier_mul(pubkey,ciper_H[i],temp[i],ciper_G[i]);
		}

		paillier_mul(pubkey,ciper_O[i],ciper_H[i],ciper_minus);	// PI
		paillier_exp(pubkey,ciper_O[i],ciper_O[i],Rand_value);
		// paillier_exp(pubkey,temp3[i],ciper_W[i],Rand_value);   // our IDEA
		// paillier_mul(pubkey,ciper_L[i],temp2[i], temp3[i]);	 // our IDEA
		
		paillier_mul(pubkey, ciper_L[i], ciper_O[i], ciper_W[i]);
	}

	alpha = Smax_basic2(ciper_R, ciper_L, ciper_M, alpha);

	gmp_printf("alpha %Zd\n", paillier_dec(0, pubkey, prvkey, alpha));
	
	for(i=0;i<size;i++){
		paillier_exp(pubkey,tmp,alpha,Rand_value);
		paillier_subtract(pubkey, ciper_lambda[i], ciper_M[i], tmp);
		if(func){
			paillier_mul(pubkey,ciper_min[i],ciper1[i],ciper_lambda[i]);			
		}else{
			paillier_mul(pubkey,ciper_min[i],ciper2[i],ciper_lambda[i]);			
		}
	}

	for(i=0; i<size; i++){
			gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, ciper_min[i]));
	}
	printf("\n");


	paillier_freeplaintext(Rand_value);		 
	paillier_freeciphertext(ciper_Rand_value);	paillier_freeciphertext(tmp);
	
	paillier_freeciphertext(alpha);

	for(i=0; i<size; i++){
		paillier_freeciphertext(ciper_W[i]);	paillier_freeciphertext(ciper_R[i]); paillier_freeciphertext(ciper_H[i]);	paillier_freeciphertext(ciper_L[i]);	paillier_freeciphertext(ciper_M[i]);
		paillier_freeciphertext(temp[i]); paillier_freeciphertext(temp2[i]);	paillier_freeciphertext(temp3[i]);
		paillier_freeciphertext(ciper_lambda[i]);
	}
	
	return ciper_min;
}

// 150809. added by KHI.
paillier_ciphertext_t* protocol::Smax_basic2(paillier_ciphertext_t** ciper_R, paillier_ciphertext_t** ciper_L, paillier_ciphertext_t** ciper_M, paillier_ciphertext_t* alpha)
{
	int i;
	int flag = 0;

	// compute alpha
	for(i=0; i<size; i++)	{
		if (strcmp( paillier_plaintext_to_str( paillier_dec(0, pubkey, prvkey, ciper_L[i])), paillier_plaintext_to_str(plain_one)) == 0) {
			alpha = paillier_enc(0, pubkey, plain_zero, paillier_get_rand_devurandom);
			paillier_print("alpha : ", alpha);
			
			flag = 1;
			
			break;
		}
		else {
			alpha = paillier_enc(0, pubkey, plain_one, paillier_get_rand_devurandom);
			paillier_print("alpha : ", alpha);
		}
	}

	if(flag == 1) {
		for(i=0; i<size; i++){
			paillier_exp(pubkey, ciper_M[i], ciper_R[i], plain_zero);
		}
	}
	else {
		for(i=0; i<size; i++){
			paillier_exp(pubkey, ciper_M[i], ciper_R[i], plain_one);
		}
	}

	paillier_print("alpha : ", alpha);

	return alpha;
}


// added by mc. 0731
paillier_ciphertext_t* protocol::faster_SRO(paillier_ciphertext_t*** qLL, paillier_ciphertext_t*** qRR, paillier_ciphertext_t*** nodeLL, paillier_ciphertext_t*** nodeRR)
{
	//printf("\n===== Now faster_SRO starts ===== \n");
	
	int i, j = 0;
	
	BOOL func = false;
	paillier_plaintext_t* Rand_value=paillier_plaintext_from_ui(5);
	paillier_ciphertext_t* ciper_Rand_value = paillier_enc(0, pubkey, Rand_value, paillier_get_rand_devurandom);	

	paillier_ciphertext_t** ciper_W		 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_G	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_H		 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_L		 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_M		 = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** ciper_PI	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));

	//paillier_ciphertext_t* alpha = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	//mpz_init(alpha->c);
	paillier_plaintext_t* alpha = paillier_plaintext_from_ui(0);


	//paillier_ciphertext_t* final_alpha = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
	//mpz_init(final_alpha->c);
	paillier_plaintext_t* final_alpha = paillier_plaintext_from_ui(0);


	paillier_ciphertext_t* tmp		= paillier_create_enc_zero();
	paillier_ciphertext_t** temp	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));
	paillier_ciphertext_t** temp2	= (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*(size+1));

	for(i=0; i<size+1; i++){
		ciper_W[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_G[i]	 = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_H[i]	 = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_L[i]	= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_M[i]	 = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		ciper_PI[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		temp[i]	= (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		temp2[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));

		mpz_init(ciper_W[i]->c);
		mpz_init(ciper_G[i]->c);
		mpz_init(ciper_H[i]->c);
		mpz_init(ciper_L[i]->c);
		mpz_init(ciper_M[i]->c);
		mpz_init(ciper_PI[i]->c);
		mpz_init(temp[i]->c);
		mpz_init(temp2[i]->c);
	}

	// q.LL 및 node.RR에 대해서 수행
	for(i=0; i<dim; i++) {
		//printf("\n%dth dimension\n", i);
		
		for(j=0; j<size+1; j++) {
			// compute W
			if(func){	// true :  F : u>v	
				paillier_subtract(pubkey, ciper_W[j], qLL[i][j], SM_p1(qLL[i][j], nodeRR[i][j]));	
			}else{
				paillier_subtract(pubkey, ciper_W[j], nodeRR[i][j], SM_p1(qLL[i][j], nodeRR[i][j]));
			}

			// compute G
			ciper_G[j]=SBXOR(qLL[i][j],nodeRR[i][j]);

			// compute H
			if(j==0){
				paillier_exp(pubkey,ciper_H[j], ciper_zero, Rand_value);
				paillier_mul(pubkey,ciper_H[j], ciper_H[j], ciper_G[j]);
			}else{
				paillier_exp(pubkey,temp[j],ciper_H[j-1],Rand_value);
				paillier_mul(pubkey,ciper_H[j],temp[j],ciper_G[j]);
			}
		}

		for(j=0; j<size+1; j++){
			// compute PI
			paillier_mul(pubkey, ciper_PI[j], ciper_H[j], ciper_minus);	// PI

			// compute L with enhanced privacy (new IDEA)
			mpz_init(temp[i]->c);
			paillier_exp(pubkey,temp[j],ciper_PI[j],Rand_value);	// randomize PI
			paillier_exp(pubkey,temp2[j],ciper_W[j],Rand_value); // randomize W
			paillier_mul(pubkey,ciper_L[j],temp[j], temp2[j]);
		}

		alpha = faster_SRO2(ciper_L, alpha);

		if(func){
			//alpha = SBN(alpha);
			if(strcmp( paillier_plaintext_to_str(alpha), paillier_plaintext_to_str(plain_zero)) == 0)
				alpha=plain_one;
			else
				alpha=plain_zero;
		}
		//gmp_printf("alpha %Zd\n", paillier_dec(0, pubkey, prvkey, alpha));
		
		//이 부분에 알파가 0이면 break!!
		if(strcmp( paillier_plaintext_to_str(alpha), paillier_plaintext_to_str(plain_zero)) == 0)
			return ciper_zero;	

		// AND operation (using SM Protocol) 
		if(i == 0)			
			plain_mul(pubkey,final_alpha,plain_one,alpha);//sm -> 그냥 평문의 곱으로 !!
			//final_alpha = SM_p1(ciper_one, alpha);	// 최초에는 1과 AND 연산을 해야함. 한번이라도 0이 나오면 0으로 바뀌는 논리
		else
			plain_mul(pubkey,final_alpha,final_alpha,alpha);
			//final_alpha = SM_p1(final_alpha, alpha);

		//gmp_printf("final alpha (after) %Zd\n", paillier_dec(0, pubkey, prvkey, alpha));
	}
	//printf("check (%d line)\n", __LINE__);

	// q.RR 및 node.LL에 대해서 수행
	for(i=0; i<dim; i++) {
		//printf("\n%dth dimension\n", i);		
		for(j=0; j<size+1; j++) {
			// compute W
			if(func){	// true :  F : u>v	
				paillier_subtract(pubkey, ciper_W[j], nodeLL[i][j], SM_p1(nodeLL[i][j], qRR[i][j]));	
			}else{
				paillier_subtract(pubkey, ciper_W[j], qRR[i][j], SM_p1(nodeLL[i][j], qRR[i][j]));
			}

			// compute G
			ciper_G[j]=SBXOR(nodeLL[i][j], qRR[i][j]);

			// compute H
			if(j==0){
				paillier_exp(pubkey,ciper_H[j], ciper_zero, Rand_value);
				paillier_mul(pubkey,ciper_H[j], ciper_H[j], ciper_G[j]);
			}else{
				paillier_exp(pubkey,temp[j],ciper_H[j-1],Rand_value);
				paillier_mul(pubkey,ciper_H[j],temp[j],ciper_G[j]);
			}
		}

		for(j=0; j<size+1; j++){
			// compute PI
			paillier_mul(pubkey, ciper_PI[j], ciper_H[j], ciper_minus);	// PI

			// compute L with enhanced privacy (new IDEA)
			mpz_init(temp[i]->c);
			paillier_exp(pubkey,temp[j],ciper_PI[j],Rand_value);	// randomize PI
			paillier_exp(pubkey,temp2[j],ciper_W[j],Rand_value); // randomize W
			paillier_mul(pubkey,ciper_L[j],temp[j], temp2[j]);
		}

		alpha = faster_SRO2(ciper_L, alpha);
		
		if(func){
			//alpha = SBN(alpha);
			if(strcmp( paillier_plaintext_to_str(alpha), paillier_plaintext_to_str(plain_zero)) == 0)
				alpha=plain_one;
			else
				alpha=plain_zero;
		}
		//gmp_printf("alpha %Zd\n", paillier_dec(0, pubkey, prvkey, alpha));
		
		//이 부분에 알파가 0이면 break!!
		if(strcmp( paillier_plaintext_to_str(alpha), paillier_plaintext_to_str(plain_zero)) == 0)
			return ciper_zero;		
	
		// AND operation (using SM Protocol) 
		//final_alpha = SM_p1(final_alpha, alpha);
		plain_mul(pubkey,final_alpha,final_alpha,alpha);

	}

	// free memory
	paillier_freeplaintext(Rand_value);	 
	paillier_freeciphertext(ciper_Rand_value);		paillier_freeciphertext(tmp);

	//paillier_freeplaintext(alpha);
	
	
	for(i=0; i<size+1; i++){
		paillier_freeciphertext(ciper_W[i]);	paillier_freeciphertext(ciper_H[i]);	paillier_freeciphertext(ciper_L[i]);	paillier_freeciphertext(ciper_M[i]);
		paillier_freeciphertext(temp[i]); paillier_freeciphertext(temp2[i]);	
	}

	return paillier_enc(0, pubkey, final_alpha, paillier_get_rand_devurandom);		
}

// added by mc. 0731   //평문으로 바꾸고
paillier_plaintext_t*  protocol::faster_SRO2(paillier_ciphertext_t** ciper_L, paillier_plaintext_t* alpha)
{
	int i;

	// compute alpha
	for(i=0; i<size+1; i++)	{
		if (strcmp( paillier_plaintext_to_str( paillier_dec(0, pubkey, prvkey, ciper_L[i])), paillier_plaintext_to_str(plain_zero)) == 0) {
			//alpha = paillier_enc(0, pubkey, plain_zero, paillier_get_rand_devurandom);
			alpha = plain_zero;
			//plain_print("alpha 0 : ", alpha);
			break;
		}
		else {
			//alpha = paillier_enc(0, pubkey, plain_one, paillier_get_rand_devurandom);
			alpha = plain_one;
			//plain_print("alpha 1 : ", alpha);
		}
	}

	//plain_print("alpha : ", alpha);
	
	return alpha;
}

paillier_ciphertext_t*** protocol::faster_sRange(paillier_ciphertext_t*** data, boundary q, boundary* node, int NumData, int NumNode, int* result_num)
{
	printf("\n===== Now sRange starts =====\n");
	//printf("NumNode : %d\n", NumNode);
	int i=0, j=0, m=0;

	time_t startTime = 0;
	time_t endTime = 0;
	float gap = 0.0;

	int** node_group;

	//startTime = clock();

	paillier_ciphertext_t*** ciper_qLL_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);
	paillier_ciphertext_t*** ciper_qRR_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);
	paillier_ciphertext_t*** ciper_nodeLL_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);
	paillier_ciphertext_t*** ciper_nodeRR_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);

	paillier_ciphertext_t** alpha = (paillier_ciphertext_t**) malloc(sizeof(paillier_ciphertext_t*)*NumNode);
	for(i=0; i<NumNode; i++){
		alpha[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		mpz_init(alpha[i]->c);
	}
	
	// query 비트 변환 수행
	for(i=0; i<dim; i++) {
		//gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, q.LL[i]));

		ciper_qLL_bit[i] = SBD_for_SRO(q.LL[i], 0);			// query LL bound 변환
		//gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, q.RR[i]));

		ciper_qRR_bit[i] = SBD_for_SRO(q.RR[i], 1);		// query RR bound 변환
	}

	//endTime = clock();
	//gap = (float)(endTime-startTime)/(CLOCKS_PER_SEC);
	//printf("query SBD time: %f\n", gap);

/*	
	printf("Query LL bound\n");
	for(i=0; i<dim; i++) {
		for(j=0; j<size+1; j++) {
			gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, ciper_qLL_bit[i][j]));
		}
		printf("\n");
	}
	printf("Query RR bound\n");
	for(i=0; i<dim; i++) {	
		for(j=0; j<size+1; j++) {
			gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, ciper_qRR_bit[i][j]));
		}
		printf("\n");
	}
*/	

	// 각 노드 비트 변환 수행 및 SRO 호출
	for(i=0; i<NumNode; i++) {	
		//startTime = clock();
		for(j=0; j<dim; j++) {
			ciper_nodeLL_bit[j] = SBD_for_SRO(node[i].LL[j], 0);				// node LL bound 변환
			ciper_nodeRR_bit[j] = SBD_for_SRO(node[i].RR[j], 1);	 			// node RR bound 변환
		}
		//endTime = clock();
		//gap = (float)(endTime-startTime)/(CLOCKS_PER_SEC);
		//printf("%dth node SBD time: %f\n", i, gap);

	/*	
		printf("%dth node LL bound\n", i);
		for(j=0; j<dim; j++) {
			for(m=0; m<size+1; m++) {
				gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, ciper_nodeLL_bit[j][m]));
			}
			printf("\n");
		}
		printf("%dth node RR bound\n", i);
		for(j=0; j<dim; j++) {
			for(m=0; m<size+1; m++) {
				gmp_printf("%Zd", paillier_dec(0, pubkey, prvkey, ciper_nodeRR_bit[j][m]));
			}
			printf("\n");
		}
	*/	
		//startTime = clock();
		alpha[i] = faster_SRO(ciper_qLL_bit, ciper_qRR_bit, ciper_nodeLL_bit, ciper_nodeRR_bit);		
		//endTime = clock();
		//gap = (float)(endTime-startTime)/(CLOCKS_PER_SEC);
		//printf("SRO time : %f\n", gap);
	/*	
		if(strcmp( paillier_plaintext_to_str( paillier_dec(0, pubkey, prvkey, alpha[i])), paillier_plaintext_to_str(plain_one)) == 0) 
			printf("%dth node overlaps the query region.\n", i);
	*/		
	}
/*
	printf("alpha\n");
	for(i=0; i<NumNode; i++) {
		gmp_printf("%Zd ",paillier_dec(0, pubkey, prvkey, alpha[i]));
	}
	printf("\n");
*/
	int NumNodeGroup;
	node_group = sRange_sub(alpha, NumNode, &NumNodeGroup);
	//printf("111set_num : %d\n", NumNodeGroup);
/*
	for(i=0; i<NumNodeGroup; i++) {
		printf("%dth Node Group : ", i);
		for(j=1; j<=node_group[i][0]; j++) {	// 0번지에 해당 노드 그룹에 몇개의 노드가 있는지가 저장되어 있음
			printf("%d ", node_group[i][j]);
		}
		printf("\n");
	}
*/
	int nodeId = 0;
	int dataId = 0;
	int z = 0;
	int cnt = 0;
	int remained = 0;	  // 노드 그룹 내에서 아직 처리할 데이터가 남아있는 노드가 몇개인지 저장함

	paillier_ciphertext_t** tmp = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*dim);
	for( i = 0 ; i < dim; i++ ){
		tmp[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		mpz_init(tmp[i]->c);
	}

	paillier_ciphertext_t*** cand = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*NumNodeGroup*FanOut);
		
	for( i = 0 ; i < NumNodeGroup*FanOut ; i++ ){
		cand[i] = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*dim);
		for( j = 0 ; j < dim ; j ++ ){
			//cand[i][j] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
			//mpz_init(cand[i][j]->c);
			cand[i][j] = paillier_create_enc_zero();
		}
	}



	// 노드 그룹 별로 데이터 추출을 통해, 질의 영역을 포함하는 노드 내 데이터 추출
	// 노드 별 데이터 수가 다른 경우에 대한 예외 처리 추가해야 함!!
	for(i=0; i<NumNodeGroup; i++) {
		remained = node_group[i][0];	 // 해당 노드 그룹 내에서 아직 처리할 데이터가 남아있는 노드가 몇개인지 저장함

		for(j=0; j<FanOut; j++) {
			if(remained == 0)	// 해당 노드 그룹 내에서 더 이상 처리할 데이터가 없다면, 다음 노드로 넘어감
				break;

			for(m=1; m<=node_group[i][0]; m++) {	 // 0번지에 해당 노드 그룹에 몇개의 노드가 있는지가 저장되어 있음
				nodeId = node_group[i][m];	 // 노드 그룹에서 노드 ID를 하나씩 꺼냄
				//printf("selecte node ID : %d\n", nodeId);

				if(node[nodeId].NumData >= j+1) 
				{
					dataId = node[nodeId].indata_id[j];	// 해당 노드에 저장된 데이터 ID를 하나씩 꺼냄
					//printf("selecte data ID : %d\n", dataId);

					for(z=0; z<dim; z++) {
						if(m == 1) {
							//gmp_printf("data : %Zd, alpha : %Zd \n", paillier_dec(0, pubkey, prvkey,data[dataId][z]), paillier_dec(0, pubkey, prvkey, alpha[nodeId]));
							//printf("cnt : %d,  dim : %d\n", cnt, z);
							cand[cnt][z] = SM_p1(data[dataId][z], alpha[nodeId]);  // 해당 데이터 ID의 실제 데이터에 접근
							//gmp_printf("%Zd \n", paillier_dec(0, pubkey, prvkey, cand[cnt][z]));
						} else {
							//gmp_printf("data : %Zd, alpha : %Zd \n", paillier_dec(0, pubkey, prvkey,data[dataId][z]), paillier_dec(0, pubkey, prvkey, alpha[nodeId]));
							//printf("cnt : %d,  dim : %d\n", cnt, z);
							tmp[z] = SM_p1(data[dataId][z], alpha[nodeId]);  // 해당 데이터 ID의 실제 데이터에 접근
							//gmp_printf("%Zd \n", paillier_dec(0, pubkey, prvkey, cand[cnt][z]));
							//gmp_printf("%Zd \n", paillier_dec(0, pubkey, prvkey, tmp[z]));
							paillier_mul(pubkey, cand[cnt][z], cand[cnt][z], tmp[z]);
							//gmp_printf("(%Zd)\n", paillier_dec(0, pubkey, prvkey, cand[cnt][z]));
						}
					}
					//printf("\n");

					if(node[nodeId].NumData == j+1)		// 해당 노드가 마지막 데이터를 처리한다면, remained를 1 감소시킴
						remained--;
				}
				else {		// 해당 노드에는 데이터가 없지만, 동일 노드 그룹 내 다른 노드에는 아직 처리할 데이터가 있는 경우를 핸들링
					for(z=0; z<dim; z++) {
						if(m == 1) {
							//gmp_printf("data : %Zd, alpha : %Zd \n", paillier_dec(0, pubkey, prvkey, ciper_MAX), paillier_dec(0, pubkey, prvkey, alpha[nodeId]));
							//printf("cnt : %d,  dim : %d\n", cnt, z);
							cand[cnt][z] = SM_p1(ciper_MAX, alpha[nodeId]);  // 해당 데이터 ID의 실제 데이터에 접근
							//gmp_printf("%Zd \n", paillier_dec(0, pubkey, prvkey, cand[cnt][z]));
						} else {
							//gmp_printf("data : %Zd, alpha : %Zd \n", paillier_dec(0, pubkey, prvkey, ciper_MAX), paillier_dec(0, pubkey, prvkey, alpha[nodeId]));
							//printf("cnt : %d,  dim : %d\n", cnt, z);
							tmp[z] = SM_p1(ciper_MAX, alpha[nodeId]);  // 해당 데이터 ID의 실제 데이터에 접근
							//gmp_printf("%Zd \n", paillier_dec(0, pubkey, prvkey, cand[cnt][z]));
							//gmp_printf("%Zd \n", paillier_dec(0, pubkey, prvkey, tmp[z]));
							paillier_mul(pubkey, cand[cnt][z], cand[cnt][z], tmp[z]);
							//gmp_printf("(%Zd)\n", paillier_dec(0, pubkey, prvkey, cand[cnt][z]));
						}
					}
					//printf("\n");
				}
				}
			cnt++;	// 노드 그룹의 노드들을 한바퀴 돌고나면, 데이터 하나가 완성됨
		}
	}

/*
	for(i=0; i<cnt; i++) {
		gmp_printf("%dth data -> coord : ", i);
		for(j=0; j<dim; j++) {
			gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, cand[i][j]));
		}
		printf("\n");
	}
*/	



	paillier_ciphertext_t*** candLL_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);
	paillier_ciphertext_t*** candRR_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);



	for( i = 0 ; i < dim ; i++ ){		
		candLL_bit[i] = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size+1);
		candRR_bit[i] = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*size+1);
		/*for( j = 0 ; j < size+1 ; j ++ ){
			candLL_bit[i][j] = paillier_create_enc_zero();	// 초기화만 해줘도 될듯!!??
			candRR_bit[i][j] = paillier_create_enc_zero();	// 초기화만 해줘도 될듯!!??     에러나면 주석 풀기!
		}*/
	}	

	paillier_ciphertext_t** alpha_mc = (paillier_ciphertext_t**) malloc(sizeof(paillier_ciphertext_t*)*cnt);

	// cand 비트 변환 수행 및 SPE호출
	for(i=0; i<cnt; i++) {
		for(j=0; j<dim; j++) {
			candLL_bit[j] = SBD_for_SRO(cand[i][j], 0);			// query cand 변환
			candRR_bit[j] = SBD_for_SRO(cand[i][j], 1);		
		}		
		
/*
			printf("candLL : ");
			for(j=0; j<dim; j++) {
				for(m=0; m<size+1; m++) {
					gmp_printf("%Zd ",paillier_dec(0, pubkey, prvkey, candLL_bit[j][m]));
				}
			}
			printf("candRR : ");
			for(j=0; j<dim; j++) {
				for(m=0; m<size+1; m++) {
					gmp_printf("%Zd ",paillier_dec(0, pubkey, prvkey, candRR_bit[j][m]));
				}
			}
			printf("qLL : ");
			for(j=0; j<dim; j++) {
				for(m=0; m<size+1; m++) {
					gmp_printf("%Zd ",paillier_dec(0, pubkey, prvkey, ciper_qLL_bit[j][m]));
				}
			}
			printf("qRR : ");
			for(j=0; j<dim; j++) {
				for(m=0; m<size+1; m++) {
					gmp_printf("%Zd ",paillier_dec(0, pubkey, prvkey, ciper_qRR_bit[j][m]));
				}
			}

			printf("\n");
*/

		//alpha[i]=SRO(candLL_bit,candRR_bit,ciper_qLL_bit, ciper_qRR_bit);
		alpha_mc[i]=faster_SRO(candLL_bit,candRR_bit,ciper_qLL_bit, ciper_qRR_bit);

		//printf("check (%d line)\n", __LINE__);	
		//alpha[i]=SPE(cand_bit,ciper_nodeLL_bit, ciper_nodeRR_bit);		
	}

/*
	//알파값 확인
	printf("SPE alpha\n");
	for(i=0; i<cnt; i++) {
		//gmp_printf("%Zd ",paillier_dec(0, pubkey, prvkey, alpha[i]));
		gmp_printf("%Zd ",paillier_dec(0, pubkey, prvkey, alpha_mc[i]));
	}
	printf("\n");	
*/

	paillier_ciphertext_t*** result = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*NumNodeGroup*FanOut); //할당방법 변경해야하고
	//int result_number=0;

	//값 확인 && If αi = 1, E(t’i)를 result에 삽입
	for(i=0; i<cnt; i++){
		//if(strcmp( paillier_plaintext_to_str( paillier_dec(0, pubkey, prvkey, alpha[i])), paillier_plaintext_to_str(plain_one)) == 0) 
		if(strcmp( paillier_plaintext_to_str( paillier_dec(0, pubkey, prvkey, alpha_mc[i])), paillier_plaintext_to_str(plain_one)) == 0) 
		{
			/*printf("%dth point overlaps the query region.\n", i);	//값 확인 		
			gmp_printf("%dth data -> coord : ", i);
			for(j=0; j<dim; j++) {
				gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, cand[i][j]));				
			}
			*/
			result[(*result_num)]=cand[i]; //result에 삽입
			(*result_num)++;
			//printf("\n");
		}
			
	}

/*	
	//result 확인
	for(i=0;i<(*result_num);i++){
		printf("%dth result.\n", i);
		for(j=0; j<dim; j++) {				
				gmp_printf("%Zd ", paillier_dec(0, pubkey, prvkey, result[i][j]));				
			}
		printf("\n");
	}
*/
/*
	free(ciper_qLL_bit); free(ciper_qRR_bit); free(ciper_nodeLL_bit); free(ciper_nodeRR_bit); free(alpha); free(tmp); free(cand); 
	free(candLL_bit); free(candRR_bit); free(alpha_mc); free(result);
	
	for(i=0; i<dim; i++){		
		for(j=0; j<size; j++){
			paillier_freeciphertext(ciper_qLL_bit[i][j]);
			paillier_freeciphertext(ciper_qRR_bit[i][j]);
			paillier_freeciphertext(ciper_nodeLL_bit[i][j]);
			paillier_freeciphertext(ciper_nodeRR_bit[i][j]);
		}
		paillier_freeciphertext(tmp[i]);		
	}

	for(i=0; i<dim; i++){		
		for(j=0; j<size; j++){
			paillier_freeciphertext(candLL_bit[i][j]);
			paillier_freeciphertext(candRR_bit[i][j]);
		}		
	}



	for(i=0; i<cnt-1; i++){
		paillier_freeciphertext(alpha_mc[i]);
	}

	
	for(i=0; i<NumNodeGroup*FanOut;i++){
		for(j=0; j<dim; j++){
			paillier_freeciphertext(cand[i][j]);
		}
	}
*/


	return result;
	

}

paillier_ciphertext_t*  protocol::SSR(paillier_ciphertext_t* ciper){
	int rand = 6;
	paillier_plaintext_t* temp = paillier_plaintext_from_ui(rand);
	rand = rand * rand;
	printf("rand : %d\n", rand);

	paillier_plaintext_t* tmp = paillier_plaintext_from_ui(rand);
	paillier_ciphertext_t* ciper_rand = paillier_create_enc(rand);

	paillier_exp(pub, ciper, ciper, tmp);
	paillier_print("mul : ", ciper);
	ciper = SSR_sub(ciper);
	paillier_print("root : ", ciper);
	paillier_divide(pub, ciper, ciper, temp);
	paillier_print("divide : ", ciper);

	free(temp);
	free(tmp);
	free(ciper_rand);
	
	return ciper;
}

paillier_ciphertext_t*  protocol::SSR_sub(paillier_ciphertext_t* ciper){
	paillier_plaintext_t* tmp = paillier_dec(0, pub, prv, ciper);
	int temp = mpz_get_si(tmp->m);
	mpz_sqrt(tmp->m, tmp->m);
	ciper = paillier_enc(0, pub, tmp, paillier_get_rand_devurandom);
	return ciper;
}



void protocol::sRange_basic(paillier_ciphertext_t*** data, boundary q, boundary* node, int NumData, int NumNode,int* result_num)
{
	printf("\n===== Now sRange starts =====\n");
	printf("NumNode : %d\n", NumNode);
	int i=0, j=0, m=0;

	time_t startTime = 0;
	time_t endTime = 0;
	float gap = 0.0;

	int NumNodeGroup = 0;

	paillier_ciphertext_t*** ciper_qLL_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);
	paillier_ciphertext_t*** ciper_qRR_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);
	paillier_ciphertext_t*** ciper_nodeLL_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);
	paillier_ciphertext_t*** ciper_nodeRR_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);

	
	// query 비트 변환 수행
	for(i=0; i<dim; i++) {
		ciper_qLL_bit[i] = SBD_for_SRO(q.LL[i], 0);			// query LL bound 변환
		ciper_qRR_bit[i] = SBD_for_SRO(q.RR[i], 1);		// query RR bound 변환
	}


	/* 
	printf("Query LL bound\n");
	for(i=0; i<dim; i++) {
		for(j=0; j<size+1; j++) {
			gmp_printf("%Zd", paillier_dec(0, pub, prv, ciper_qLL_bit[i][j]));
		}
		printf("\n");
	}
	printf("Query RR bound\n");
	for(i=0; i<dim; i++) {	
		for(j=0; j<size+1; j++) {
			gmp_printf("%Zd", paillier_dec(0, pub, prv, ciper_qRR_bit[i][j]));
		}
		printf("\n");
	}
	*/


	
	paillier_ciphertext_t** alpha = (paillier_ciphertext_t**) malloc(sizeof(paillier_ciphertext_t*)*NumData);
	for(i=0; i<NumNode; i++){
		alpha[i] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
		mpz_init(alpha[i]->c);
	}
	
	/*		
	paillier_ciphertext_t*** cand = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*(*NumNodeGroup)*FanOut);
	for( i = 0 ; i < *NumNodeGroup*FanOut ; i++ ){
		cand[i] = (paillier_ciphertext_t**)malloc(sizeof(paillier_ciphertext_t*)*dim);
		for( j = 0 ; j < dim ; j ++ ){
			cand[i][j] = (paillier_ciphertext_t*) malloc(sizeof(paillier_ciphertext_t));
			mpz_init(cand[i][j]->c);
		}
	}
	*/



	//paillier_ciphertext_t*** cand ;

	//cand = sNodeRetrievalforRange(data, ciper_qLL_bit, ciper_qRR_bit, node, NumData, NumNode, &cnt, &NumNodeGroup);

	paillier_ciphertext_t*** candLL_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);
	paillier_ciphertext_t*** candRR_bit = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*dim);




	for(i=0; i<NumData; i++) {
		for(j=0; j<dim; j++) {
			candLL_bit[j] = SBD_for_SRO(data[i][j], 0);			// query cand 변환
			candRR_bit[j] = SBD_for_SRO(data[i][j], 1);		
		}		
		alpha[i]=SRO(candLL_bit,candRR_bit,ciper_qLL_bit, ciper_qRR_bit);
		//alpha[i]=SPE(cand_bit,ciper_nodeLL_bit, ciper_nodeRR_bit);		
	}

/*
	//알파값 확인
	printf("SPE alpha\n");
	for(i=0; i<NumData; i++) {
		gmp_printf("%Zd ",paillier_dec(0, pub, prv, alpha[i]));
	}
	printf("\n");	
*/
	paillier_ciphertext_t*** result = (paillier_ciphertext_t***)malloc(sizeof(paillier_ciphertext_t**)*100); //할당방법 변경해야하고
	//int result_num=0;

	//값 확인 && If αi = 1, E(t’i)를 result에 삽입
	for(i=0; i<NumData; i++){
		if(strcmp( paillier_plaintext_to_str( paillier_dec(0, pub, prv, alpha[i])), paillier_plaintext_to_str(plain_one)) == 0) 
		{
			printf("%dth point overlaps the query region.\n", i);	//값 확인 		
			//gmp_printf("%dth data -> coord : ", i);
			for(j=0; j<dim; j++) {
				gmp_printf("%Zd ", paillier_dec(0, pub, prv, data[i][j]));				
			}

			result[(*result_num)]=data[i]; //result에 삽입
			(*result_num)++;
			printf("\n");
		}	
	}
	
	//result 확인
	for(i=0;i<(*result_num);i++){
		printf("%dth result.\n", i);
		for(j=0; j<dim; j++) {				
				gmp_printf("%Zd ", paillier_dec(0, pub, prv, result[i][j]));				
			}
		printf("\n");
	}
}